// main.dart - アプリケーションのエントリーポイント
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'screens/home_screen.dart';
import 'screens/tasks_screen.dart';
import 'screens/statistics_screen.dart';
import 'screens/settings_screen.dart';
import 'providers/task_provider.dart';
import 'providers/pomodoro_provider.dart';
import 'providers/app_restriction_provider.dart';
import 'services/database_helper.dart';
import 'services/notification_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await DatabaseHelper.instance.database;
  await NotificationService().init();
  
  // アプリ設定の初期化
  final prefs = await SharedPreferences.getInstance();
  
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => TaskProvider()),
        ChangeNotifierProvider(create: (_) => PomodoroProvider(prefs)),
        ChangeNotifierProvider(create: (_) => AppRestrictionProvider()),
      ],
      child: const MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'ポモドーロ学習管理',
      theme: ThemeData(
        primarySwatch: Colors.red,
        visualDensity: VisualDensity.adaptivePlatformDensity,
        fontFamily: 'NotoSansJP',
      ),
      darkTheme: ThemeData(
        brightness: Brightness.dark,
        primarySwatch: Colors.red,
        visualDensity: VisualDensity.adaptivePlatformDensity,
        fontFamily: 'NotoSansJP',
      ),
      themeMode: ThemeMode.system,
      home: const MainScreen(),
    );
  }
}

class MainScreen extends StatefulWidget {
  const MainScreen({Key? key}) : super(key: key);

  @override
  _MainScreenState createState() => _MainScreenState();
}

class _MainScreenState extends State<MainScreen> {
  int _selectedIndex = 0;
  
  final List<Widget> _screens = [
    const HomeScreen(),
    const TasksScreen(),
    const StatisticsScreen(),
    const SettingsScreen(),
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _screens[_selectedIndex],
      bottomNavigationBar: BottomNavigationBar(
        type: BottomNavigationBar.Fixed,
        currentIndex: _selectedIndex,
        onTap: (index) {
          setState(() {
            _selectedIndex = index;
          });
        },
        items: const [
          BottomNavigationBar.Item(
            icon: Icon(Icons.home),
            label: 'ホーム',
          ),
          BottomNavigationBar.Item(
            icon: Icon(Icons.task),
            label: 'タスク',
          ),
          BottomNavigationBar.Item(
            icon: Icon(Icons.bar_chart),
            label: '統計',
          ),
          BottomNavigationBar.Item(
            icon: Icon(Icons.settings),
            label: '設定',
          ),
        ],
      ),
    );
  }
}

// models/task.dart - タスクモデル
class Task {
  final int? id;
  final String name;
  final String category;
  final String description;
  final int estimatedPomodoros;
  int completedPomodoros;
  final DateTime createdAt;
  DateTime updatedAt;
  final String? tickTickId;

  Task({
    this.id,
    required this.name,
    required this.category,
    this.description = '',
    required this.estimatedPomodoros,
    this.completedPomodoros = 0,
    DateTime? createdAt,
    DateTime? updatedAt,
    this.tickTickId,
  }) : 
    this.createdAt = createdAt ?? DateTime.now(),
    this.updatedAt = updatedAt ?? DateTime.now();

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'category': category,
      'description': description,
      'estimatedPomodoros': estimatedPomodoros,
      'completedPomodoros': completedPomodoros,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
      'tickTickId': tickTickId,
    };
  }

  factory Task.fromMap(Map<String, dynamic> map) {
    return Task(
      id: map['id'],
      name: map['name'],
      category: map['category'],
      description: map['description'],
      estimatedPomodoros: map['estimatedPomodoros'],
      completedPomodoros: map['completedPomodoros'],
      createdAt: DateTime.parse(map['createdAt']),
      updatedAt: DateTime.parse(map['updatedAt']),
      tickTickId: map['tickTickId'],
    );
  }

  Task copyWith({
    int? id,
    String? name,
    String? category,
    String? description,
    int? estimatedPomodoros,
    int? completedPomodoros,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? tickTickId,
  }) {
    return Task(
      id: id ?? this.id,
      name: name ?? this.name,
      category: category ?? this.category,
      description: description ?? this.description,
      estimatedPomodoros: estimatedPomodoros ?? this.estimatedPomodoros,
      completedPomodoros: completedPomodoros ?? this.completedPomodoros,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      tickTickId: tickTickId ?? this.tickTickId,
    );
  }
}

// models/pomodoro_session.dart - ポモドーロセッションモデル
class PomodoroSession {
  final int? id;
  final int taskId;
  final DateTime startTime;
  final DateTime endTime;
  final int durationMinutes;
  final bool completed;
  final double focusScore;

  PomodoroSession({
    this.id,
    required this.taskId,
    required this.startTime,
    required this.endTime,
    required this.durationMinutes,
    this.completed = true,
    this.focusScore = 100.0,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'taskId': taskId,
      'startTime': startTime.toIso8601String(),
      'endTime': endTime.toIso8601String(),
      'durationMinutes': durationMinutes,
      'completed': completed ? 1 : 0,
      'focusScore': focusScore,
    };
  }

  factory PomodoroSession.fromMap(Map<String, dynamic> map) {
    return PomodoroSession(
      id: map['id'],
      taskId: map['taskId'],
      startTime: DateTime.parse(map['startTime']),
      endTime: DateTime.parse(map['endTime']),
      durationMinutes: map['durationMinutes'],
      completed: map['completed'] == 1,
      focusScore: map['focusScore'],
    );
  }
}

// providers/pomodoro_provider.dart - ポモドーロタイマー管理
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/task.dart';
import '../models/pomodoro_session.dart';
import '../services/database_helper.dart';
import '../services/notification_service.dart';

class PomodoroProvider with ChangeNotifier {
  // タイマー設定
  int workDuration = 25; // 作業時間（分）
  int shortBreakDuration = 5; // 短い休憩時間（分）
  int longBreakDuration = 15; // 長い休憩時間（分）
  int longBreakInterval = 4; // 長い休憩までのポモドーロ数

  // タイマー状態
  bool isRunning = false;
  bool isPaused = false;
  bool isBreak = false;
  int remainingSeconds = 0;
  int completedPomodoros = 0;
  int totalSeconds = 0;
  Timer? _timer;

  // 現在のタスク
  Task? currentTask;

  // セッション記録
  DateTime? sessionStartTime;

  final SharedPreferences prefs;
  final notificationService = NotificationService();

  PomodoroProvider(this.prefs) {
    // 設定の読み込み
    workDuration = prefs.getInt('workDuration') ?? 25;
    shortBreakDuration = prefs.getInt('shortBreakDuration') ?? 5;
    longBreakDuration = prefs.getInt('longBreakDuration') ?? 15;
    longBreakInterval = prefs.getInt('longBreakInterval') ?? 4;
  }

  // タイマーを開始
  void startTimer(Task task) {
    currentTask = task;
    isRunning = true;
    isPaused = false;
    isBreak = false;
    
    totalSeconds = workDuration * 60;
    remainingSeconds = totalSeconds;
    sessionStartTime = DateTime.now();
    
    _startCountdown();
    notifyListeners();
  }

  // 休憩タイマーを開始
  void startBreak() {
    isRunning = true;
    isPaused = false;
    isBreak = true;
    
    // 長い休憩か短い休憩かを決定
    final isLongBreak = (completedPomodoros % longBreakInterval == 0);
    final breakDuration = isLongBreak ? longBreakDuration : shortBreakDuration;
    
    totalSeconds = breakDuration * 60;
    remainingSeconds = totalSeconds;
    
    _startCountdown();
    notifyListeners();
  }

  // カウントダウンを開始
  void _startCountdown() {
    _timer?.cancel();
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (remainingSeconds > 0) {
        remainingSeconds--;
        notifyListeners();
      } else {
        _timer?.cancel();
        
        if (!isBreak) {
          // ポモドーロが完了
          _completePomodoro();
          notificationService.showNotification(
            'ポモドーロ完了', 
            '休憩時間です。次のセッションを始める準備をしましょう。'
          );
        } else {
          // 休憩が完了
          isBreak = false;
          isRunning = false;
          notificationService.showNotification(
            '休憩終了', 
            '次のポモドーロセッションを始めましょう。'
          );
        }
        
        notifyListeners();
      }
    });
  }

  // ポモドーロを完了としてマーク
  Future<void> _completePomodoro() async {
    if (currentTask == null || sessionStartTime == null) return;
    
    completedPomodoros++;
    
    // セッションを記録
    final session = PomodoroSession(
      taskId: currentTask!.id!,
      startTime: sessionStartTime!,
      endTime: DateTime.now(),
      durationMinutes: workDuration,
      completed: true,
      focusScore: _calculateFocusScore(),
    );
    
    // データベースに保存
    await DatabaseHelper.instance.insertPomodoroSession(session);
    
    // タスクの完了ポモドーロ数を更新
    currentTask = currentTask!.copyWith(
      completedPomodoros: currentTask!.completedPomodoros + 1,
      updatedAt: DateTime.now(),
    );
    
    await DatabaseHelper.instance.updateTask(currentTask!);
  }

  // 集中度スコアを計算（デモとして単純な実装）
  double _calculateFocusScore() {
    // ここで集中度を計算するロジックを実装
    // 実際のアプリでは、一時停止回数や中断時間などから計算
    return 100.0;
  }

  // タイマーを一時停止
  void pauseTimer() {
    if (isRunning && !isPaused) {
      isPaused = true;
      _timer?.cancel();
      notifyListeners();
    }
  }

  // タイマーを再開
  void resumeTimer() {
    if (isRunning && isPaused) {
      isPaused = false;
      _startCountdown();
      notifyListeners();
    }
  }

  // タイマーをキャンセル
  void cancelTimer() {
    _timer?.cancel();
    isRunning = false;
    isPaused = false;
    notifyListeners();
  }

  // 設定を保存
  Future<void> saveSettings({
    int? workDuration,
    int? shortBreakDuration,
    int? longBreakDuration,
    int? longBreakInterval,
  }) async {
    if (workDuration != null) {
      this.workDuration = workDuration;
      await prefs.setInt('workDuration', workDuration);
    }
    
    if (shortBreakDuration != null) {
      this.shortBreakDuration = shortBreakDuration;
      await prefs.setInt('shortBreakDuration', shortBreakDuration);
    }
    
    if (longBreakDuration != null) {
      this.longBreakDuration = longBreakDuration;
      await prefs.setInt('longBreakDuration', longBreakDuration);
    }
    
    if (longBreakInterval != null) {
      this.longBreakInterval = longBreakInterval;
      await prefs.setInt('longBreakInterval', longBreakInterval);
    }
    
    notifyListeners();
  }

  @override
  void dispose() {
    _timer?.cancel();
    super.dispose();
  }
}

// screens/home_screen.dart - ホーム画面
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/task_provider.dart';
import '../providers/pomodoro_provider.dart';
import '../widgets/pomodoro_timer.dart';
import '../widgets/task_selection.dart';
import '../widgets/daily_progress.dart';

class HomeScreen extends StatelessWidget {
  const HomeScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final pomodoroProvider = Provider.of<PomodoroProvider>(context);
    final taskProvider = Provider.of<TaskProvider>(context);

    return Scaffold(
      appBar: AppBar(
        title: Text('ポモドーロ学習管理'),
        centerTitle: true,
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // ポモドーロタイマーウィジェット
              PomodoroTimer(
                isRunning: pomodoroProvider.isRunning,
                isPaused: pomodoroProvider.isPaused,
                isBreak: pomodoroProvider.isBreak,
                remainingSeconds: pomodoroProvider.remainingSeconds,
                totalSeconds: pomodoroProvider.totalSeconds,
                onStart: () {
                  if (pomodoroProvider.currentTask != null) {
                    pomodoroProvider.startTimer(pomodoroProvider.currentTask!);
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('タスクを選択してください')),
                    );
                  }
                },
                onPause: pomodoroProvider.pauseTimer,
                onResume: pomodoroProvider.resumeTimer,
                onCancel: pomodoroProvider.cancelTimer,
              ),
              
              const SizedBox(height: 24),
              
              // 現在のタスク表示
              if (pomodoroProvider.isRunning)
                Card(
                  elevation: 2,
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          '現在のタスク:',
                          style: Theme.of(context).textTheme.subtitle1,
                        ),
                        const SizedBox(height: 8),
                        Text(
                          pomodoroProvider.currentTask?.name ?? '選択されていません',
                          style: Theme.of(context).textTheme.headline6,
                        ),
                        const SizedBox(height: 4),
                        Text(
                          '${pomodoroProvider.currentTask?.completedPomodoros ?? 0} / ${pomodoroProvider.currentTask?.estimatedPomodoros ?? 0} ポモドーロ',
                          style: Theme.of(context).textTheme.subtitle2,
                        ),
                      ],
                    ),
                  ),
                )
              else
                // タスク選択ウィジェット
                TaskSelection(
                  tasks: taskProvider.tasks,
                  onTaskSelected: (task) {
                    pomodoroProvider.currentTask = task;
                  },
                ),
              
              const SizedBox(height: 24),
              
              // 今日の進捗サマリー
              const DailyProgress(),
            ],
          ),
        ),
      ),
    );
  }
}

// widgets/pomodoro_timer.dart - ポモドーロタイマーウィジェット
import 'package:flutter/material.dart';

class PomodoroTimer extends StatelessWidget {
  final bool isRunning;
  final bool isPaused;
  final bool isBreak;
  final int remainingSeconds;
  final int totalSeconds;
  final VoidCallback onStart;
  final VoidCallback onPause;
  final VoidCallback onResume;
  final VoidCallback onCancel;

  const PomodoroTimer({
    Key? key,
    required this.isRunning,
    required this.isPaused,
    required this.isBreak,
    required this.remainingSeconds,
    required this.totalSeconds,
    required this.onStart,
    required this.onPause,
    required this.onResume,
    required this.onCancel,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final minutes = (remainingSeconds / 60).floor();
    final seconds = remainingSeconds % 60;
    
    return Card(
      elevation: 4,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          children: [
            Text(
              isBreak ? '休憩時間' : '作業時間',
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: isBreak ? Colors.green : Colors.red,
              ),
            ),
            const SizedBox(height: 16),
            Stack(
              alignment: Alignment.center,
              children: [
                SizedBox(
                  width: 200,
                  height: 200,
                  child: CircularProgressIndicator(
                    value: totalSeconds > 0 ? remainingSeconds / totalSeconds : 0,
                    strokeWidth: 12,
                    backgroundColor: Colors.grey[300],
                    valueColor: AlwaysStoppedAnimation<Color>(
                      isBreak ? Colors.green : Colors.red,
                    ),
                  ),
                ),
                Text(
                  '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}',
                  style: const TextStyle(
                    fontSize: 48,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 24),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                if (!isRunning)
                  ElevatedButton.icon(
                    icon: const Icon(Icons.play_arrow),
                    label: const Text('開始'),
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 24,
                        vertical: 12,
                      ),
                    ),
                    onPressed: onStart,
                  )
                else if (isPaused)
                  ElevatedButton.icon(
                    icon: const Icon(Icons.play_arrow),
                    label: const Text('再開'),
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 24,
                        vertical: 12,
                      ),
                    ),
                    onPressed: onResume,
                  )
                else
                  ElevatedButton.icon(
                    icon: const Icon(Icons.pause),
                    label: const Text('一時停止'),
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 24,
                        vertical: 12,
                      ),
                    ),
                    onPressed: onPause,
                  ),
                const SizedBox(width: 16),
                if (isRunning)
                  OutlinedButton.icon(
                    icon: const Icon(Icons.stop),
                    label: const Text('中止'),
                    style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 24,
                        vertical: 12,
                      ),
                    ),
                    onPressed: onCancel,
                  ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

// screens/statistics_screen.dart - 統計画面
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:provider/provider.dart';
import '../providers/task_provider.dart';
import '../services/database_helper.dart';
import '../models/pomodoro_session.dart';

class StatisticsScreen extends StatefulWidget {
  const StatisticsScreen({Key? key}) : super(key: key);

  @override
  _StatisticsScreenState createState() => _StatisticsScreenState();
}

class _StatisticsScreenState extends State<StatisticsScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }
  
  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('学習統計'),
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(text: '日別'),
            Tab(text: '週別'),
            Tab(text: 'タスク別'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: const [
          DailyStatisticsTab(),
          WeeklyStatisticsTab(),
          TaskStatisticsTab(),
        ],
      ),
    );
  }
}

class DailyStatisticsTab extends StatelessWidget {
  const DailyStatisticsTab({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<List<Map<String, dynamic>>>(
      future: DatabaseHelper.instance.getDailyStatistics(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        
        if (snapshot.hasError) {
          return Center(child: Text('エラーが発生しました: ${snapshot.error}'));
        }
        
        final data = snapshot.data ?? [];
        
        if (data.isEmpty) {
          return const Center(child: Text('データがありません'));
        }
        
        return Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                '日別ポモドーロ完了数',
                style: Theme.of(context).textTheme.headline6,
              ),
              const SizedBox(height: 16),
              Expanded(
                child: BarChart(
                  BarChartData(
                    alignment: BarChartAlignment.spaceAround,
                    maxY: data.map((e) => e['count'] as int).reduce((a, b) => a > b ? a : b) * 1.2,
                    barTouchData: BarTouchData(
                      enabled: true,
                      touchTooltipData: BarTouchTooltipData(
                        tooltipBgColor: Colors.blueGrey,
                        getTooltipItem: (group, groupIndex, rod, rodIndex) {
                          return BarTooltipItem(
                            '${data[groupIndex]['date']}\n',
                            const TextStyle(color: Colors.white),
                            children: <TextSpan>[
                              TextSpan(
                                text: '${rod.toY.round()} ポモドーロ',
                                style: const TextStyle(
                                  color: Colors.yellow,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                          );
                        },
                      ),
                    ),
                    titlesData: FlTitlesData(
                      show: true,
                      bottomTitles: AxisTitles(
                        sideTitles: SideTitles(
                          showTitles: true,
                          getTitlesWidget: (value, meta) {
                            final index = value.toInt();
                            if (index >= 0 && index < data.length) {
                              final date = data[index]['date'] as String;
                              return Padding(
                                padding: const EdgeInsets.only(top: 8.0),
                                child: Text(
                                  date.substring(5), // 月/日のみ表示
                                  style: const TextStyle(
                                    fontSize: 12,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              );
                            }
                            return const Text('');
                          },
                        ),
                      ),
                      leftTitles: AxisTitles(
                        sideTitles: SideTitles(
                          showTitles: true,
                          reservedSize: 30,
                          getTitlesWidget: (value, meta) {
                            if (value == 0) {
                              return const Text('0');
                            }
                            return Text(value.toInt().toString());
                          },
                        ),
                      ),
                      topTitles: AxisTitles(
                        sideTitles: SideTitles(showTitles: false),
                      ),
                      rightTitles: AxisTitles(
                        sideTitles: SideTitles(showTitles: false),
                      ),
                    ),
                    borderData: FlBorderData(show: false),
                    barGroups: data.asMap().entries.map((entry) {
                      final index = entry.key;
                      final item = entry.value;
                      return BarChartGroupData(
                        x: index,
                        barRods: [
                          BarChartRodData(
                            toY: item['count'].toDouble(),
                            color: Colors.red,
                            width: 20,
                            borderRadius: const BorderRadius.only(
                              topLeft: Radius.circular(6),
                              topRight: Radius.circular(6),
                            ),
                          ),
                        ],
                      );
                    }).toList(),
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

// services/database_helper.dart - データベース管理
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import '../models/task.dart';
import '../models/pomodoro_session.dart';
import '../models/restricted_app.dart';

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;

  DatabaseHelper._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('pomodoro_app.db');
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    return await openDatabase(
      path,
      version: 1,
      onCreate: _createDB,
    );
  }

  Future<void> _createDB(Database db, int version) async {
    await db.execute('''
      CREATE TABLE tasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        category TEXT NOT NULL,
        description TEXT,
        estimatedPomodoros INTEGER NOT NULL,
        completedPomodoros INTEGER NOT NULL,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL,
        tickTickId TEXT
      )
    ''');

    await db.execute('''
      CREATE TABLE pomodoro_sessions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        taskId INTEGER NOT NULL,
        startTime TEXT NOT NULL,
        endTime TEXT NOT NULL,
        durationMinutes INTEGER NOT NULL,
        completed INTEGER NOT NULL,
        focusScore REAL NOT NULL,
        FOREIGN KEY (taskId) REFERENCES tasks (id) ON DELETE CASCADE
      )
    ''');

    await db.execute('''
      CREATE TABLE restricted_apps (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        executablePath TEXT NOT NULL,
        allowedMinutesPerDay INTEGER NOT NULL,
        isRestricted INTEGER NOT NULL,
        requiredPomodorosToUnlock INTEGER NOT NULL
      )
    ''');
  }

  // タスク関連のメソッド
  Future<int> insertTask(Task task) async {
    final db = await database;
    return await db.insert('tasks', task.toMap());
  }

  Future<List<Task>> getTasks() async {
    final db = await database;
    final results = await db.query('tasks', orderBy: 'updatedAt DESC');
    return results.map((map) => Task.fromMap(map)).toList();
  }

  Future<Task?> getTask(int id) async {
    final db = await database;
    final results = await db.query(
      'tasks',
      where: 'id = ?',
      whereArgs: [id],
    );
    
    if (results.isNotEmpty) {
      return Task.fromMap(results.first);
    }
    return null;
  }

  Future<int> updateTask(Task task) async {
    final db = await database;
    return await db.update(
      'tasks',
      task.toMap(),
      where: 'id = ?',
      whereArgs: [task.id],
    );
  }

  Future<int> deleteTask(int id) async {
    final db = await database;
    return await db.delete(
      'tasks',
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  // ポモドーロセッション関連のメソッド
  Future<int> insertPomodoroSession(PomodoroSession session) async {
    final db = await database;
    return await db.insert('pomodoro_sessions', session.toMap());
  }

  Future<List<PomodoroSession>> getPomodoroSessions() async {
    final db = await database;
    final results = await db.query('pomodoro_sessions', orderBy: 'startTime DESC');
    return results.map((map) => PomodoroSession.fromMap(map)).toList();
  }

  Future<List<PomodoroSession>> getTaskPomodoroSessions(int taskId) async {
    final db = await database;
    final results = await db.query(
      'pomodoro_sessions',
      where: 'taskId = ?',
      whereArgs: [taskId],
      orderBy: 'startTime DESC',
    );
    return results.map((map) => PomodoroSession.fromMap(map)).toList();
  }

  // 統計関連のメソッド
  Future<List<Map<String, dynamic>>> getDailyStatistics() async {
    final db = await database;
    final results = await db.rawQuery('''
      SELECT 
        date(startTime) as date,
        COUNT(*) as count,
        SUM(durationMinutes) as totalMinutes
      FROM pomodoro_sessions
      WHERE completed = 1
      GROUP BY date(startTime)
      ORDER BY date(startTime) DESC
      LIMIT 7
    ''');
    
    return results.reversed.toList();
  }

  Future<List<Map<String, dynamic>>> getWeeklyStatistics() async {
    final db = await database;
    final results = await db.rawQuery('''
      SELECT 
        strftime('%Y-%W', startTime) as week,
        COUNT(*) as count,
        SUM(durationMinutes) as totalMinutes
      FROM pomodoro_sessions
      WHERE completed = 1
      GROUP BY strftime('%Y-%W', startTime)
      ORDER BY week DESC
      LIMIT 8
    ''');
    
    return results.reversed.toList();
  }

  Future<List<Map<String, dynamic>>> getTaskStatistics() async {
    final db = await database;
    return await db.rawQuery('''
      SELECT 
        t.id,
        t.name,
        t.category,
        COUNT(ps.id) as sessionCount,
        SUM(ps.durationMinutes) as totalMinutes,
        AVG(ps.focusScore) as avgFocusScore
      FROM tasks t
      LEFT JOIN pomodoro_sessions ps ON t.id = ps.taskId AND ps.completed = 1
      GROUP BY t.id
      ORDER BY totalMinutes DESC
    ''');
  }

  Future<List<Map<String, dynamic>>> getCategoryStatistics() async {
    final db = await database;
    return await db.rawQuery('''
      SELECT 
        t.category,
        COUNT(ps.id) as sessionCount,
        SUM(ps.durationMinutes) as totalMinutes
      FROM tasks t
      LEFT JOIN pomodoro_sessions ps ON t.id = ps.taskId AND ps.completed = 1
      GROUP BY t.category
      ORDER BY totalMinutes DESC
    ''');
  }
}




/*

a
a
a
a
a
a






































*/

// windows_app_controller.dart - Windowsアプリ制御実装
import 'dart:ffi';
import 'dart:io';
import 'package:ffi/ffi.dart';
import 'package:win32/win32.dart';
import '../models/restricted_app.dart';
import '../services/database_helper.dart';

class WindowsAppController {
  static final WindowsAppController _instance = WindowsAppController._internal();
  factory WindowsAppController() => _instance;
  
  WindowsAppController._internal();
  
  bool _isMonitoring = false;
  
  // 制限対象アプリのリスト
  List<RestrictedApp> _restrictedApps = [];
  
  // 今日のポモドーロ完了数
  int _completedPomodorosToday = 0;
  
  // 初期化
  Future<void> initialize() async {
    if (!Platform.isWindows) return;
    
    // DBから制限対象アプリを読み込む
    await _loadRestrictedApps();
    
    // 今日のポモドーロ完了数を取得
    await _loadCompletedPomodorosToday();
  }
  
  // DBから制限対象アプリを読み込む
  Future<void> _loadRestrictedApps() async {
    final db = await DatabaseHelper.instance.database;
    final results = await db.query('restricted_apps', where: 'isRestricted = 1');
    _restrictedApps = results.map((map) => RestrictedApp.fromMap(map)).toList();
  }
  
  // 今日のポモドーロ完了数を取得
  Future<void> _loadCompletedPomodorosToday() async {
    final db = await DatabaseHelper.instance.database;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day).toIso8601String();
    
    final results = await db.rawQuery('''
      SELECT COUNT(*) as count
      FROM pomodoro_sessions
      WHERE date(startTime) = date(?) AND completed = 1
    ''', [today]);
    
    if (results.isNotEmpty) {
      _completedPomodorosToday = results.first['count'] as int;
    }
  }
  
  // 監視を開始
  void startMonitoring() {
    if (!Platform.isWindows || _isMonitoring) return;
    
    _isMonitoring = true;
    _monitorApps();
  }
  
  // 監視を停止
  void stopMonitoring() {
    _isMonitoring = false;
  }
  
  // アプリの監視処理
  Future<void> _monitorApps() async {
    if (!Platform.isWindows) return;
    
    while (_isMonitoring) {
      final runningApps = _getRunningApplications();
      
      for (final app in _restrictedApps) {
        final isRunning = runningApps.any((process) => 
          process.executablePath.toLowerCase() == app.executablePath.toLowerCase());
        
        if (isRunning) {
          // アプリが実行中で、制限条件に合致する場合は終了させる
          if (_completedPomodorosToday < app.requiredPomodorosToUnlock) {
            _terminateApplication(app.executablePath);
            _showNotification(app);
          }
        }
      }
      
      // 一定間隔で監視
      await Future.delayed(const Duration(seconds: 5));
    }
  }
  
  // 実行中のアプリケーション一覧を取得
  List<ProcessInfo> _getRunningApplications() {
    final processes = <ProcessInfo>[];
    
    // スナップショットを取得
    final hSnapshot = CreateToolhelp32Snapshot(
        TH32CS_SNAPPROCESS, 0);
    
    if (hSnapshot == INVALID_HANDLE_VALUE) {
      return processes;
    }
    
    try {
      // PROCESSENTRY32 構造体を初期化
      final pe32 = calloc<PROCESSENTRY32>();
      pe32.ref.dwSize = sizeOf<PROCESSENTRY32>();
      
      // 最初のプロセスを取得
      if (Process32First(hSnapshot, pe32) != 0) {
        do {
          final processId = pe32.ref.th32ProcessID;
          final executablePath = _getProcessExecutablePath(processId);
          
          if (executablePath.isNotEmpty) {
            processes.add(ProcessInfo(
              processId: processId,
              executablePath: executablePath,
            ));
          }
        } while (Process32Next(hSnapshot, pe32) != 0);
      }
      
      free(pe32);
    } finally {
      CloseHandle(hSnapshot);
    }
    
    return processes;
  }
  
  // プロセスIDから実行パスを取得
  String _getProcessExecutablePath(int processId) {
    final hProcess = OpenProcess(
      PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
      FALSE,
      processId,
    );
    
    if (hProcess == 0) {
      return '';
    }
    
    try {
      final pathBuffer = calloc<Uint16>(MAX_PATH).cast<Utf16>();
      final len = GetModuleFileNameEx(
        hProcess,
        0,
        pathBuffer,
        MAX_PATH,
      );
      
      if (len == 0) {
        free(pathBuffer);
        return '';
      }
      
      final path = pathBuffer.toDartString();
      free(pathBuffer);
      return path;
    } finally {
      CloseHandle(hProcess);
    }
  }
  
  // アプリケーションを終了させる
  void _terminateApplication(String executablePath) {
    final runningApps = _getRunningApplications();
    
    for (final process in runningApps) {
      if (process.executablePath.toLowerCase() == executablePath.toLowerCase()) {
        final hProcess = OpenProcess(
          PROCESS_TERMINATE,
          FALSE,
          process.processId,
        );
        
        if (hProcess != 0) {
          TerminateProcess(hProcess, 0);
          CloseHandle(hProcess);
        }
      }
    }
  }
  
  // 通知を表示
  void _showNotification(RestrictedApp app) {
    // トースト通知を表示（実際にはFlutterの通知機能を使用）
    // この例では簡略化のためにコンソール出力のみ
    print('アプリ「${app.name}」はポモドーロ ${app.requiredPomodorosToUnlock} 回の完了が必要です');
  }
  
  // 完了ポモドーロ数を更新
  Future<void> updateCompletedPomodoros(int count) async {
    _completedPomodorosToday = count;
  }
  
  // 制限対象アプリを追加
  Future<void> addRestrictedApp(RestrictedApp app) async {
    final db = await DatabaseHelper.instance.database;
    final id = await db.insert('restricted_apps', app.toMap());
    
    final newApp = app.copyWith(id: id);
    _restrictedApps.add(newApp);
  }
  
  // 制限対象アプリを更新
  Future<void> updateRestrictedApp(RestrictedApp app) async {
    final db = await DatabaseHelper.instance.database;
    await db.update(
      'restricted_apps',
      app.toMap(),
      where: 'id = ?',
      whereArgs: [app.id],
    );
    
    final index = _restrictedApps.indexWhere((a) => a.id == app.id);
    if (index >= 0) {
      _restrictedApps[index] = app;
    }
  }
  
  // 制限対象アプリを削除
  Future<void> removeRestrictedApp(int id) async {
    final db = await DatabaseHelper.instance.database;
    await db.delete(
      'restricted_apps',
      where: 'id = ?',
      whereArgs: [id],
    );
    
    _restrictedApps.removeWhere((app) => app.id == id);
  }
}

// ProcessInfo class - プロセス情報を保持するクラス
class ProcessInfo {
  final int processId;
  final String executablePath;
  
  ProcessInfo({
    required this.processId,
    required this.executablePath,
  });
}

// models/restricted_app.dart - 制限対象アプリモデル
class RestrictedApp {
  final int? id;
  final String name;
  final String executablePath;
  final int allowedMinutesPerDay;
  final bool isRestricted;
  final int requiredPomodorosToUnlock;

  RestrictedApp({
    this.id,
    required this.name,
    required this.executablePath,
    required this.allowedMinutesPerDay,
    required this.isRestricted,
    required this.requiredPomodorosToUnlock,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'executablePath': executablePath,
      'allowedMinutesPerDay': allowedMinutesPerDay,
      'isRestricted': isRestricted ? 1 : 0,
      'requiredPomodorosToUnlock': requiredPomodorosToUnlock,
    };
  }

  factory RestrictedApp.fromMap(Map<String, dynamic> map) {
    return RestrictedApp(
      id: map['id'],
      name: map['name'],
      executablePath: map['executablePath'],
      allowedMinutesPerDay: map['allowedMinutesPerDay'],
      isRestricted: map['isRestricted'] == 1,
      requiredPomodorosToUnlock: map['requiredPomodorosToUnlock'],
    );
  }

  RestrictedApp copyWith({
    int? id,
    String? name,
    String? executablePath,
    int? allowedMinutesPerDay,
    bool? isRestricted,
    int? requiredPomodorosToUnlock,
  }) {
    return RestrictedApp(
      id: id ?? this.id,
      name: name ?? this.name,
      executablePath: executablePath ?? this.executablePath,
      allowedMinutesPerDay: allowedMinutesPerDay ?? this.allowedMinutesPerDay,
      isRestricted: isRestricted ?? this.isRestricted,
      requiredPomodorosToUnlock: requiredPomodorosToUnlock ?? this.requiredPomodorosToUnlock,
    );
  }
}

// providers/app_restriction_provider.dart - アプリ制限管理のProvider
import 'package:flutter/material.dart';
import '../models/restricted_app.dart';
import '../services/database_helper.dart';
import 'windows_app_controller.dart';

class AppRestrictionProvider with ChangeNotifier {
  final _windowsAppController = WindowsAppController();
  List<RestrictedApp> restrictedApps = [];
  bool isMonitoring = false;

  AppRestrictionProvider() {
    _initializeController();
    _loadRestrictedApps();
  }

  Future<void> _initializeController() async {
    await _windowsAppController.initialize();
  }

  Future<void> _loadRestrictedApps() async {
    final db = await DatabaseHelper.instance.database;
    final results = await db.query('restricted_apps');
    restrictedApps = results.map((map) => RestrictedApp.fromMap(map)).toList();
    notifyListeners();
  }

  // 監視を開始
  void startMonitoring() {
    _windowsAppController.startMonitoring();
    isMonitoring = true;
    notifyListeners();
  }

  // 監視を停止
  void stopMonitoring() {
    _windowsAppController.stopMonitoring();
    isMonitoring = false;
    notifyListeners();
  }

  // 制限対象アプリを追加
  Future<void> addRestrictedApp(RestrictedApp app) async {
    await _windowsAppController.addRestrictedApp(app);
    await _loadRestrictedApps();
  }

  // 制限対象アプリを更新
  Future<void> updateRestrictedApp(RestrictedApp app) async {
    await _windowsAppController.updateRestrictedApp(app);
    await _loadRestrictedApps();
  }

  // 制限対象アプリを削除
  Future<void> removeRestrictedApp(int id) async {
    await _windowsAppController.removeRestrictedApp(id);
    await _loadRestrictedApps();
  }

  // ポモドーロ完了時に呼び出し
  Future<void> onPomodoroCompleted() async {
    final db = await DatabaseHelper.instance.database;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day).toIso8601String();
    
    final results = await db.rawQuery('''
      SELECT COUNT(*) as count
      FROM pomodoro_sessions
      WHERE date(startTime) = date(?) AND completed = 1
    ''', [today]);
    
    if (results.isNotEmpty) {
      final count = results.first['count'] as int;
      await _windowsAppController.updateCompletedPomodoros(count);
    }
  }
}

// screens/app_restriction_screen.dart - アプリ制限設定画面
import 'package:flutter/material.dart';
import 'package:file_picker/file_picker.dart';
import 'package:provider/provider.dart';
import '../providers/app_restriction_provider.dart';
import '../models/restricted_app.dart';

class AppRestrictionScreen extends StatefulWidget {
  const AppRestrictionScreen({Key? key}) : super(key: key);

  @override
  _AppRestrictionScreenState createState() => _AppRestrictionScreenState();
}

class _AppRestrictionScreenState extends State<AppRestrictionScreen> {
  @override
  Widget build(BuildContext context) {
    final appRestrictionProvider = Provider.of<AppRestrictionProvider>(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('アプリ制限設定'),
      ),
      body: Column(
        children: [
          // 監視オン/オフスイッチ
          SwitchListTile(
            title: const Text('アプリ制限を有効にする'),
            subtitle: const Text('ポモドーロ目標達成まで指定アプリの使用を制限します'),
            value: appRestrictionProvider.isMonitoring,
            onChanged: (value) {
              if (value) {
                appRestrictionProvider.startMonitoring();
              } else {
                appRestrictionProvider.stopMonitoring();
              }
            },
          ),
          
          const Divider(),
          
          // 制限対象アプリのリスト
          Expanded(
            child: ListView.builder(
              itemCount: appRestrictionProvider.restrictedApps.length,
              itemBuilder: (context, index) {
                final app = appRestrictionProvider.restrictedApps[index];
                return ListTile(
                  leading: const Icon(Icons.apps),
                  title: Text(app.name),
                  subtitle: Text('必要ポモドーロ: ${app.requiredPomodorosToUnlock}回'),
                  trailing: Switch(
                    value: app.isRestricted,
                    onChanged: (value) {
                      appRestrictionProvider.updateRestrictedApp(
                        app.copyWith(isRestricted: value),
                      );
                    },
                  ),
                  onTap: () => _showEditAppDialog(context, app),
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        child: const Icon(Icons.add),
        onPressed: () => _showAddAppDialog(context),
      ),
    );
  }

  // アプリ追加ダイアログ
  Future<void> _showAddAppDialog(BuildContext context) async {
    final formKey = GlobalKey<FormState>();
    String appName = '';
    String executablePath = '';
    int requiredPomodoros = 5;
    
    return showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('制限対象アプリを追加'),
          content: Form(
            key: formKey,
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextFormField(
                    decoration: const InputDecoration(
                      labelText: 'アプリ名',
                      hintText: '例: ゲーム、SNSアプリなど',
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'アプリ名を入力してください';
                      }
                      return null;
                    },
                    onSaved: (value) {
                      appName = value!;
                    },
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Expanded(
                        child: TextFormField(
                          decoration: const InputDecoration(
                            labelText: '実行ファイルパス',
                            hintText: 'C:\\Program Files\\App\\app.exe',
                          ),
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return '実行ファイルパスを入力してください';
                            }
                            return null;
                          },
                          onSaved: (value) {
                            executablePath = value!;
                          },
                        ),
                      ),
                      IconButton(
                        icon: const Icon(Icons.folder_open),
                        onPressed: () async {
                          final result = await FilePicker.platform.pickFiles(
                            type: FileType.custom,
                            allowedExtensions: ['exe'],
                          );
                          
                          if (result != null && result.files.isNotEmpty) {
                            executablePath = result.files.first.path!;
                            // フォームフィールドを更新するには、コントローラーを使用する必要があります
                          }
                        },
                      ),
                    ],
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    decoration: const InputDecoration(
                      labelText: '必要ポモドーロ回数',
                      hintText: '例: 5',
                    ),
                    keyboardType: TextInputType.number,
                    initialValue: '5',
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return '回数を入力してください';
                      }
                      final number = int.tryParse(value);
                      if (number == null || number <= 0) {
                        return '正の整数を入力してください';
                      }
                      return null;
                    },
                    onSaved: (value) {
                      requiredPomodoros = int.parse(value!);
                    },
                  ),
                ],
              ),
            ),
          ),
          actions: [
            TextButton(
              child: const Text('キャンセル'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            ElevatedButton(
              child: const Text('追加'),
              onPressed: () {
                if (formKey.currentState!.validate()) {
                  formKey.currentState!.save();
                  
                  final provider = Provider.of<AppRestrictionProvider>(context, listen: false);
                  
                  provider.addRestrictedApp(RestrictedApp(
                    name: appName,
                    executablePath: executablePath,
                    allowedMinutesPerDay: 0,
                    isRestricted: true,
                    requiredPomodorosToUnlock: requiredPomodoros,
                  ));
                  
                  Navigator.of(context).pop();
                }
              },
            ),
          ],
        );
      },
    );
  }

  // アプリ編集ダイアログ
  Future<void> _showEditAppDialog(BuildContext context, RestrictedApp app) async {
    final formKey = GlobalKey<FormState>();
    String appName = app.name;
    String executablePath = app.executablePath;
    int requiredPomodoros = app.requiredPomodorosToUnlock;
    
    return showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('制限対象アプリを編集'),
          content: Form(
            key: formKey,
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextFormField(
                    decoration: const InputDecoration(
                      labelText: 'アプリ名',
                    ),
                    initialValue: appName,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'アプリ名を入力してください';
                      }
                      return null;
                    },
                    onSaved: (value) {
                      appName = value!;
                    },
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Expanded(
                        child: TextFormField(
                          decoration: const InputDecoration(
                            labelText: '実行ファイルパス',
                          ),
                          initialValue: executablePath,
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return '実行ファイルパスを入力してください';
                            }
                            return null;
                          },
                          onSaved: (value) {
                            executablePath = value!;
                          },
                        ),
                      ),
                      IconButton(
                        icon: const Icon(Icons.folder_open),
                        onPressed: () async {
                          final result = await FilePicker.platform.pickFiles(
                            type: FileType.custom,
                            allowedExtensions: ['exe'],
                          );
                          
                          if (result != null && result.files.isNotEmpty) {
                            executablePath = result.files.first.path!;
                            // フォームフィールドを更新するには、コントローラーを使用する必要があります
                          }
                        },
                      ),
                    ],
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    decoration: const InputDecoration(
                      labelText: '必要ポモドーロ回数',
                    ),
                    keyboardType: TextInputType.number,
                    initialValue: requiredPomodoros.toString(),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return '回数を入力してください';
                      }
                      final number = int.tryParse(value);
                      if (number == null || number <= 0) {
                        return '正の整数を入力してください';
                      }
                      return null;
                    },
                    onSaved: (value) {
                      requiredPomodoros = int.parse(value!);
                    },
                  ),
                ],
              ),
            ),
          ),
          actions: [
            TextButton(
              child: const Text('キャンセル'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: const Text('削除'),
              style: TextButton.styleFrom(
                foregroundColor: Colors.red,
              ),
              onPressed: () {
                final provider = Provider.of<AppRestrictionProvider>(context, listen: false);
                provider.removeRestrictedApp(app.id!);
                Navigator.of(context).pop();
              },
            ),
            ElevatedButton(
              child: const Text('保存'),
              onPressed: () {
                if (formKey.currentState!.validate()) {
                  formKey.currentState!.save();
                  
                  final provider = Provider.of<AppRestrictionProvider>(context, listen: false);
                  
                  provider.updateRestrictedApp(app.copyWith(
                    name: appName,
                    executablePath: executablePath,
                    requiredPomodorosToUnlock: requiredPomodoros,
                  ));
                  
                  Navigator.of(context).pop();
                }
              },
            ),
          ],
        );
      },
    );
  }
}

/*




























*/

// services/ticktick_service.dart - TickTick API連携サービス
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';
import '../models/task.dart';

class TickTickService {
  static final TickTickService _instance = TickTickService._internal();
  factory TickTickService() => _instance;
  
  TickTickService._internal();
  
  // TickTick API エンドポイント
  static const String _baseUrl = 'https://api.ticktick.com/api/v2';
  static const String _authUrl = 'https://ticktick.com/oauth/token';
  
  // アクセストークン
  String? _accessToken;
  String? _refreshToken;
  DateTime? _tokenExpiry;
  
  // APIキー情報（本来は環境変数などで管理）
  // 注: 実際のアプリ開発では、クライアントIDとシークレットは安全に管理してください
  static const String _clientId = 'YOUR_TICKTICK_CLIENT_ID';
  static const String _clientSecret = 'YOUR_TICKTICK_CLIENT_SECRET';
  
  // 初期化
  Future<void> initialize() async {
    await _loadTokens();
  }
  
  // 保存されたトークンを読み込み
  Future<void> _loadTokens() async {
    final prefs = await SharedPreferences.getInstance();
    _accessToken = prefs.getString('ticktick_access_token');
    _refreshToken = prefs.getString('ticktick_refresh_token');
    
    final expiryMs = prefs.getInt('ticktick_token_expiry');
    if (expiryMs != null) {
      _tokenExpiry = DateTime.fromMillisecondsSinceEpoch(expiryMs);
    }
  }
  
  // トークンを保存
  Future<void> _saveTokens() async {
    final prefs = await SharedPreferences.getInstance();
    
    if (_accessToken != null) {
      await prefs.setString('ticktick_access_token', _accessToken!);
    }
    
    if (_refreshToken != null) {
      await prefs.setString('ticktick_refresh_token', _refreshToken!);
    }
    
    if (_tokenExpiry != null) {
      await prefs.setInt(
        'ticktick_token_expiry',
        _tokenExpiry!.millisecondsSinceEpoch,
      );
    }
  }
  
  // 認証状態をチェック
  bool get isAuthenticated {
    if (_accessToken == null || _tokenExpiry == null) {
      return false;
    }
    
    // トークンの有効期限をチェック
    final now = DateTime.now();
    return now.isBefore(_tokenExpiry!);
  }
  
  // OAuth2認証フロー（認証コードフロー）
  Future<bool> authenticate(String authCode) async {
    try {
      final response = await http.post(
        Uri.parse(_authUrl),
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: {
          'grant_type': 'authorization_code',
          'code': authCode,
          'client_id': _clientId,
          'client_secret': _clientSecret,
          'redirect_uri': 'com.yourapp.pomodoro://oauth/callback',
        },
      );
      
      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        _accessToken = data['access_token'];
        _refreshToken = data['refresh_token'];
        
        // トークンの有効期限を設定（通常は1時間）
        final expiresIn = data['expires_in'] ?? 3600;
        _tokenExpiry = DateTime.now().add(Duration(seconds: expiresIn));
        
        await _saveTokens();
        return true;
      }
      
      return false;
    } catch (e) {
      print('TickTick認証エラー: $e');
      return false;
    }
  }
  
  // アクセストークンをリフレッシュ
  Future<bool> _refreshAccessToken() async {
    if (_refreshToken == null) {
      return false;
    }
    
    try {
      final response = await http.post(
        Uri.parse(_authUrl),
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: {
          'grant_type': 'refresh_token',
          'refresh_token': _refreshToken,
          'client_id': _clientId,
          'client_secret': _clientSecret,
        },
      );
      
      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        _accessToken = data['access_token'];
        _refreshToken = data['refresh_token'];
        
        // トークンの有効期限を更新
        final expiresIn = data['expires_in'] ?? 3600;
        _tokenExpiry = DateTime.now().add(Duration(seconds: expiresIn));
        
        await _saveTokens();
        return true;
      }
      
      return false;
    } catch (e) {
      print('TickTickトークンリフレッシュエラー: $e');
      return false;
    }
  }
  
  // APIリクエストの共通処理
  Future<http.Response?> _apiRequest(
    String method,
    String endpoint,
    {Map<String, dynamic>? body}
  ) async {
    if (!isAuthenticated) {
      final refreshed = await _refreshAccessToken();
      if (!refreshed) {
        return null;
      }
    }
    
    final url = Uri.parse('$_baseUrl$endpoint');
    final headers = {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer $_accessToken',
    };
    
    http.Response response;
    
    try {
      switch (method.toUpperCase()) {
        case 'GET':
          response = await http.get(url, headers: headers);
          break;
        case 'POST':
          response = await http.post(
            url,
            headers: headers,
            body: body != null ? jsonEncode(body) : null,
          );
          break;
        case 'PUT':
          response = await http.put(
            url,
            headers: headers,
            body: body != null ? jsonEncode(body) : null,
          );
          break;
        case 'DELETE':
          response = await http.delete(url, headers: headers);
          break;
        default:
          throw Exception('Unsupported HTTP method: $method');
      }
      
      // トークンの有効期限切れの場合は再認証
      if (response.statusCode == 401) {
        final refreshed = await _refreshAccessToken();
        if (refreshed) {
          return _apiRequest(method, endpoint, body: body);
        }
        return null;
      }
      
      return response;
    } catch (e) {
      print('TickTick APIリクエストエラー: $e');
      return null;
    }
  }
  
  // タスクリストを取得
  Future<List<Task>?> fetchTasks() async {
    try {
      final response = await _apiRequest('GET', '/task');
      
      if (response == null || response.statusCode != 200) {
        return null;
      }
      
      final data = jsonDecode(response.body);
      
      if (data is List) {
        return data.map((item) => _mapTickTickTaskToTask(item)).toList();
      }
      
      return [];
    } catch (e) {
      print('TickTick タスク取得エラー: $e');
      return null;
    }
  }
  
  // TickTickのタスクをアプリのタスクモデルに変換
  Task _mapTickTickTaskToTask(Map<String, dynamic> tickTickTask) {
    return Task(
      name: tickTickTask['title'] ?? '',
      category: _extractCategoryFromTags(tickTickTask['tags']),
      description: tickTickTask['content'] ?? '',
      estimatedPomodoros: _extractEstimatedPomodorosFromTask(tickTickTask),
      completedPomodoros: 0,  // TickTickにはこの情報がないため初期値を設定
      tickTickId: tickTickTask['id'],
    );
  }
  
  // タグからカテゴリを抽出（例: 最初のタグをカテゴリとして使用）
  String _extractCategoryFromTags(List<dynamic>? tags) {
    if (tags == null || tags.isEmpty) {
      return 'その他';
    }
    return tags[0].toString();
  }
  
  // タスクから予定ポモドーロ数を抽出（例: タイトルから「[P3]」のような形式で抽出）
  int _extractEstimatedPomodorosFromTask(Map<String, dynamic> task) {
    final title = task['title'] ?? '';
    final match = RegExp(r'\[P(\d+)\]').firstMatch(title);
    
    if (match != null && match.groupCount >= 1) {
      return int.tryParse(match.group(1) ?? '0') ?? 0;
    }
    
    // デフォルト値
    return 1;
  }
  
  // ポモドーロセッション完了をTickTickに記録
  Future<bool> recordPomodoroSession(Task task, int durationMinutes) async {
    if (task.tickTickId == null) {
      return false;
    }
    
    try {
      // TickTickのタスク詳細を取得
      final taskResponse = await _apiRequest(
        'GET',
        '/task/${task.tickTickId}',
      );
      
      if (taskResponse == null || taskResponse.statusCode != 200) {
        return false;
      }
      
      final taskData = jsonDecode(taskResponse.body);
      
      // ポモドーロ記録を追加
      final pomodoros = taskData['pomodoros'] ?? [];
      pomodoros.add({
        'duration': durationMinutes,
        'startTime': DateTime.now().toIso8601String(),
      });
      
      // タスクを更新
      final updateResponse = await _apiRequest(
        'PUT',
        '/task/${task.tickTickId}',
        body: {
          ...taskData,
          'pomodoros': pomodoros,
        },
      );
      
      return updateResponse != null && updateResponse.statusCode == 200;
    } catch (e) {
      print('TickTick ポモドーロ記録エラー: $e');
      return false;
    }
  }
  
  // タスク完了をTickTickに報告
  Future<bool> completeTask(String tickTickId) async {
    try {
      final response = await _apiRequest(
        'POST',
        '/task/$tickTickId/complete',
      );
      
      return response != null && response.statusCode == 200;
    } catch (e) {
      print('TickTick タスク完了エラー: $e');
      return false;
    }
  }
  
  // TickTickからタスクをインポート
  Future<List<Task>> importTasksFromTickTick() async {
    final tasks = await fetchTasks();
    return tasks ?? [];
  }
}

// providers/ticktick_provider.dart - TickTick連携のProvider
import 'package:flutter/material.dart';
import '../models/task.dart';
import '../services/ticktick_service.dart';
import '../services/database_helper.dart';

class TickTickProvider with ChangeNotifier {
  final _tickTickService = TickTickService();
  bool isAuthenticated = false;
  bool isSyncing = false;
  DateTime? lastSyncTime;

  TickTickProvider() {
    _initialize();
  }

  Future<void> _initialize() async {
    await _tickTickService.initialize();
    isAuthenticated = _tickTickService.isAuthenticated;
    notifyListeners();
  }

  // 認証状態を確認
  Future<void> checkAuthentication() async {
    isAuthenticated = _tickTickService.isAuthenticated;
    notifyListeners();
  }

  // 認証コードを使って認証
  Future<bool> authenticate(String authCode) async {
    final success = await _tickTickService.authenticate(authCode);
    isAuthenticated = success;
    notifyListeners();
    return success;
  }

  // TickTickからタスクをインポート
  Future<List<Task>> importTasks() async {
    if (!isAuthenticated) {
      return [];
    }

    isSyncing = true;
    notifyListeners();

    try {
      final tasks = await _tickTickService.importTasksFromTickTick();
      
      // データベースに保存
      final db = DatabaseHelper.instance;
      for (final task in tasks) {
        // 既存のタスクがあるか確認
        final existingTasks = await db.getTasks();
        final exists = existingTasks.any((t) => t.tickTickId == task.tickTickId);
        
        if (!exists) {
          await db.insertTask(task);
        }
      }
      
      lastSyncTime = DateTime.now();
      return tasks;
    } finally {
      isSyncing = false;
      notifyListeners();
    }
  }

  // ポモドーロセッション完了をTickTickに記録
  Future<bool> recordPomodoroSession(Task task, int durationMinutes) async {
    if (!isAuthenticated || task.tickTickId == null) {
      return false;
    }

    final success = await _tickTickService.recordPomodoroSession(
      task,
      durationMinutes,
    );

    if (success) {
      notifyListeners();
    }

    return success;
  }

  // タスク完了をTickTickに報告
  Future<bool> completeTask(Task task) async {
    if (!isAuthenticated || task.tickTickId == null) {
      return false;
    }

    final success = await _tickTickService.completeTask(task.tickTickId!);

    if (success) {
      notifyListeners();
    }

    return success;
  }
}

// screens/ticktick_sync_screen.dart - TickTick同期設定画面
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:url_launcher/url_launcher.dart';
import '../providers/ticktick_provider.dart';
import '../providers/task_provider.dart';

class TickTickSyncScreen extends StatefulWidget {
  const TickTickSyncScreen({Key? key}) : super(key: key);

  @override
  _TickTickSyncScreenState createState() => _TickTickSyncScreenState();
}

class _TickTickSyncScreenState extends State<TickTickSyncScreen> {
  final _authCodeController = TextEditingController();
  bool _isImporting = false;
  int _importedTaskCount = 0;

  @override
  void dispose() {
    _authCodeController.dispose();
    super.dispose();
  }

  // TickTickの認証ページを開く
  Future<void> _openTickTickAuth() async {
    // 注: 実際のアプリ開発では、クライアントIDを安全に管理してください
    const clientId = 'YOUR_TICKTICK_CLIENT_ID';
    const redirectUri = 'com.yourapp.pomodoro://oauth/callback';
    
    // TickTickのOAuth2認証ページURL
    final authUrl = Uri.parse(
      'https://ticktick.com/oauth/authorize'
      '?client_id=$clientId'
      '&redirect_uri=$redirectUri'
      '&response_type=code'
      '&scope=tasks:read tasks:write',
    );
    
    if (await canLaunchUrl(authUrl)) {
      await launchUrl(
        authUrl,
        mode: LaunchMode.externalApplication,
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('ブラウザを開けませんでした')),
      );
    }
  }

  // TickTickからタスクをインポート
  Future<void> _importTasks() async {
    setState(() {
      _isImporting = true;
    });
    
    try {
      final tickTickProvider = Provider.of<TickTickProvider>(context, listen: false);
      final taskProvider = Provider.of<TaskProvider>(context, listen: false);
      
      final importedTasks = await tickTickProvider.importTasks();
      _importedTaskCount = importedTasks.length;
      
      // タスクリストを更新
      await taskProvider.loadTasks();
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('$_importedTaskCount 件のタスクをインポートしました')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('タスクのインポート中にエラーが発生しました: $e')),
      );
    } finally {
      setState(() {
        _isImporting = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final tickTickProvider = Provider.of<TickTickProvider>(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('TickTick同期設定'),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'TickTick連携状態',
                      style: Theme.of(context).textTheme.headline6,
                    ),
                    const SizedBox(height: 8),
                    Row(
                      children: [
                        Icon(
                          tickTickProvider.isAuthenticated
                              ? Icons.check_circle
                              : Icons.error,
                          color: tickTickProvider.isAuthenticated
                              ? Colors.green
                              : Colors.red,
                        ),
                        const SizedBox(width: 8),
                        Text(
                          tickTickProvider.isAuthenticated
                              ? '連携中'
                              : '未連携',
                          style: TextStyle(
                            color: tickTickProvider.isAuthenticated
                                ? Colors.green
                                : Colors.red,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ],
                    ),
                    if (tickTickProvider.lastSyncTime != null) ...[
                      const SizedBox(height: 8),
                      Text(
                        '最終同期: ${_formatDateTime(tickTickProvider.lastSyncTime!)}',
                        style: Theme.of(context).textTheme.caption,
                      ),
                    ],
                  ],
                ),
              ),
            ),
            
            const SizedBox(height: 24),
            
            if (!tickTickProvider.isAuthenticated) ...[
              Text(
                'TickTickと連携する',
                style: Theme.of(context).textTheme.headline6,
              ),
              const SizedBox(height: 16),
              ElevatedButton.icon(
                icon: const Icon(Icons.link),
                label: const Text('TickTickと連携する'),
                onPressed: _openTickTickAuth,
              ),
              const SizedBox(height: 16),
              const Text('認証後に表示される認証コードを入力:'),
              const SizedBox(height: 8),
              TextField(
                controller: _authCodeController,
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  hintText: '認証コードを入力',
                ),
              ),
              const SizedBox(height: 8),
              ElevatedButton(
                child: const Text('認証コードを送信'),
                onPressed: () async {
                  final code = _authCodeController.text.trim();
                  if (code.isEmpty) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('認証コードを入力してください')),
                    );
                    return;
                  }
                  
                  final success = await tickTickProvider.authenticate(code);
                  
                  if (success) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('TickTickとの連携に成功しました')),
                    );
                    _authCodeController.clear();
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('認証に失敗しました。コードを確認してください')),
                    );
                  }
                },
              ),
            ] else ...[
              Text(
                'TickTickからタスクをインポート',
                style: Theme.of(context).textTheme.headline6,
              ),
              const SizedBox(height: 16),
              ElevatedButton.icon(
                icon: const Icon(Icons.download),
                label: Text(_isImporting ? 'インポート中...' : 'タスクをインポート'),
                onPressed: _isImporting ? null : _importTasks,
              ),
              if (_importedTaskCount > 0) ...[
                const SizedBox(height: 8),
                Text('$_importedTaskCount 件のタスクをインポートしました'),
              ],
              
              const SizedBox(height: 24),
              
              Text(
                '同期設定',
                style: Theme.of(context).textTheme.headline6,
              ),
              const SizedBox(height: 16),
              SwitchListTile(
                title: const Text('ポモドーロ完了時に自動同期'),
                subtitle: const Text('ポモドーロセッションの完了をTickTickに記録します'),
                value: true,  // 設定値として保存・取得する実装が必要
                onChanged: (value) {
                  // 設定を保存する実装
                },
              ),
              SwitchListTile(
                title: const Text('タスク完了時に自動同期'),
                subtitle: const Text('タスクの完了状態をTickTickと同期します'),
                value: true,  // 設定値として保存・取得する実装が必要
                onChanged: (value) {
                  // 設定を保存する実装
                },
              ),
              
              const SizedBox(height: 24),
              
              OutlinedButton.icon(
                icon: const Icon(Icons.logout),
                label: const Text('連携を解除'),
                style: OutlinedButton.styleFrom(
                  foregroundColor: Colors.red,
                ),
                onPressed: () {
                  // 連携解除の実装
                  showDialog(
                    context: context,
                    builder: (context) => AlertDialog(
                      title: const Text('連携解除の確認'),
                      content: const Text('TickTickとの連携を解除しますか？'),
                      actions: [
                        TextButton(
                          child: const Text('キャンセル'),
                          onPressed: () {
                            Navigator.of(context).pop();
                          },
                        ),
                        TextButton(
                          child: const Text('解除する'),
                          style: TextButton.styleFrom(
                            foregroundColor: Colors.red,
                          ),
                          onPressed: () {
                            // 連携解除処理
                            Navigator.of(context).pop();
                          },
                        ),
                      ],
                    ),
                  );
                },
              ),
            ],
          ],
        ),
      ),
    );
  }

  // 日時のフォーマット
  String _formatDateTime(DateTime dateTime) {
    return '${dateTime.year}/${dateTime.month.toString().padLeft(2, '0')}/${dateTime.day.toString().padLeft(2, '0')} '
        '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }
}



/*










































*/
// screens/settings_screen.dart - 設定画面
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/pomodoro_provider.dart';
import '../providers/app_restriction_provider.dart';
import 'app_restriction_screen.dart';
import 'ticktick_sync_screen.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({Key? key}) : super(key: key);

  @override
  _SettingsScreenState createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  // 設定の一時保存用
  late int _workDuration;
  late int _shortBreakDuration;
  late int _longBreakDuration;
  late int _longBreakInterval;
  bool _enableNotifications = true;
  bool _enableSounds = true;
  String _selectedTheme = 'system';

  @override
  void initState() {
    super.initState();
    
    // 現在の設定を読み込み
    final pomodoroProvider = Provider.of<PomodoroProvider>(context, listen: false);
    _workDuration = pomodoroProvider.workDuration;
    _shortBreakDuration = pomodoroProvider.shortBreakDuration;
    _longBreakDuration = pomodoroProvider.longBreakDuration;
    _longBreakInterval = pomodoroProvider.longBreakInterval;
  }

  @override
  Widget build(BuildContext context) {
    final pomodoroProvider = Provider.of<PomodoroProvider>(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('設定'),
      ),
      body: ListView(
        children: [
          // タイマー設定セクション
          _buildSectionHeader(context, 'タイマー設定'),
          
          ListTile(
            title: const Text('作業時間'),
            subtitle: Text('$_workDuration 分'),
            trailing: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(
                  icon: const Icon(Icons.remove),
                  onPressed: _workDuration > 1
                      ? () => setState(() => _workDuration--)
                      : null,
                ),
                IconButton(
                  icon: const Icon(Icons.add),
                  onPressed: () => setState(() => _workDuration++),
                ),
              ],
            ),
          ),
          
          ListTile(
            title: const Text('短い休憩時間'),
            subtitle: Text('$_shortBreakDuration 分'),
            trailing: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(
                  icon: const Icon(Icons.remove),
                  onPressed: _shortBreakDuration > 1
                      ? () => setState(() => _shortBreakDuration--)
                      : null,
                ),
                IconButton(
                  icon: const Icon(Icons.add),
                  onPressed: () => setState(() => _shortBreakDuration++),
                ),
              ],
            ),
          ),
          
          ListTile(
            title: const Text('長い休憩時間'),
            subtitle: Text('$_longBreakDuration 分'),
            trailing: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(
                  icon: const Icon(Icons.remove),
                  onPressed: _longBreakDuration > 1
                      ? () => setState(() => _longBreakDuration--)
                      : null,
                ),
                IconButton(
                  icon: const Icon(Icons.add),
                  onPressed: () => setState(() => _longBreakDuration++),
                ),
              ],
            ),
          ),
          
          ListTile(
            title: const Text('長い休憩までのポモドーロ数'),
            subtitle: Text('$_longBreakInterval 回'),
            trailing: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(
                  icon: const Icon(Icons.remove),
                  onPressed: _longBreakInterval > 1
                      ? () => setState(() => _longBreakInterval--)
                      : null,
                ),
                IconButton(
                  icon: const Icon(Icons.add),
                  onPressed: () => setState(() => _longBreakInterval++),
                ),
              ],
            ),
          ),
          
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: ElevatedButton(
              child: const Text('タイマー設定を保存'),
              onPressed: () {
                pomodoroProvider.saveSettings(
                  workDuration: _workDuration,
                  shortBreakDuration: _shortBreakDuration,
                  longBreakDuration: _longBreakDuration,
                  longBreakInterval: _longBreakInterval,
                );
                
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('設定を保存しました')),
                );
              },
            ),
          ),
          
          const Divider(),
          
          // 通知と音設定
          _buildSectionHeader(context, '通知と音'),
          
          SwitchListTile(
            title: const Text('通知'),
            subtitle: const Text('ポモドーロ完了時に通知を表示します'),
            value: _enableNotifications,
            onChanged: (value) {
              setState(() {
                _enableNotifications = value;
              });
              // 通知設定を保存する実装
            },
          ),
          
          SwitchListTile(
            title: const Text('効果音'),
            subtitle: const Text('タイマー開始・終了時に音を鳴らします'),
            value: _enableSounds,
            onChanged: (value) {
              setState(() {
                _enableSounds = value;
              });
              // 音設定を保存する実装
            },
          ),
          
          const Divider(),
          
          // 外観設定
          _buildSectionHeader(context, '外観'),
          
          ListTile(
            title: const Text('テーマ'),
            subtitle: Text(_getThemeName(_selectedTheme)),
            trailing: DropdownButton<String>(
              value: _selectedTheme,
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    _selectedTheme = value;
                  });
                  // テーマ設定を保存する実装
                }
              },
              items: const [
                DropdownMenuItem(
                  value: 'system',
                  child: Text('システム設定に合わせる'),
                ),
                DropdownMenuItem(
                  value: 'light',
                  child: Text('ライトテーマ'),
                ),
                DropdownMenuItem(
                  value: 'dark',
                  child: Text('ダークテーマ'),
                ),
              ],
            ),
          ),
          
          const Divider(),
          
          // 連携設定
          _buildSectionHeader(context, '連携'),
          
          ListTile(
            title: const Text('TickTick連携'),
            subtitle: const Text('TickTickとタスクやポモドーロ記録を同期します'),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {
              Navigator.of(context).push(MaterialPageRoute(
                builder: (context) => const TickTickSyncScreen(),
              ));
            },
          ),
          
          // Windowsアプリ制限（Windowsプラットフォームのみ表示）
          if (Theme.of(context).platform == TargetPlatform.windows)
            ListTile(
              title: const Text('アプリ制限設定'),
              subtitle: const Text('ポモドーロ目標達成までアプリの使用を制限します'),
              trailing: const Icon(Icons.chevron_right),
              onTap: () {
                Navigator.of(context).push(MaterialPageRoute(
                  builder: (context) => const AppRestrictionScreen(),
                ));
              },
            ),
          
          const Divider(),
          
          // アプリについて
          _buildSectionHeader(context, 'アプリについて'),
          
          ListTile(
            title: const Text('バージョン'),
            subtitle: const Text('1.0.0'),
          ),
          
          ListTile(
            title: const Text('プライバシーポリシー'),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {
              // プライバシーポリシーを表示する実装
            },
          ),
          
          ListTile(
            title: const Text('利用規約'),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {
              // 利用規約を表示する実装
            },
          ),
        ],
      ),
    );
  }

  // セクションヘッダーウィジェット
  Widget _buildSectionHeader(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
      child: Text(
        title,
        style: Theme.of(context).textTheme.subtitle1?.copyWith(
          color: Theme.of(context).primaryColor,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  // テーマ名を取得
  String _getThemeName(String themeKey) {
    switch (themeKey) {
      case 'system':
        return 'システム設定に合わせる';
      case 'light':
        return 'ライトテーマ';
      case 'dark':
        return 'ダークテーマ';
      default:
        return 'システム設定に合わせる';
    }
  }
}

// widgets/daily_progress.dart - 日別進捗ウィジェット
import 'package:flutter/material.dart';
import '../services/database_helper.dart';

class DailyProgress extends StatelessWidget {
  const DailyProgress({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<Map<String, dynamic>>(
      future: _getDailyStats(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        
        final stats = snapshot.data ?? {
          'totalPomodoros': 0,
          'totalMinutes': 0,
          'targetPomodoros': 8,
        };
        
        final totalPomodoros = stats['totalPomodoros'] as int;
        final totalMinutes = stats['totalMinutes'] as int;
        final targetPomodoros = stats['targetPomodoros'] as int;
        final progress = totalPomodoros / targetPomodoros;
        
        return Card(
          elevation: 2,
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      '今日の進捗',
                      style: Theme.of(context).textTheme.headline6,
                    ),
                    Text(
                      '$totalPomodoros / $targetPomodoros',
                      style: Theme.of(context).textTheme.subtitle1,
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                LinearProgressIndicator(
                  value: progress.clamp(0.0, 1.0),
                  minHeight: 10,
                  backgroundColor: Colors.grey[300],
                ),
                const SizedBox(height: 16),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceAround,
                  children: [
                    _buildStatItem(
                      context,
                      Icons.timer,
                      '$totalPomodoros回',
                      'ポモドーロ',
                    ),
                    _buildStatItem(
                      context,
                      Icons.access_time,
                      '$totalMinutes分',
                      '学習時間',
                    ),
                    _buildStatItem(
                      context,
                      Icons.trending_up,
                      '${(progress * 100).toStringAsFixed(0)}%',
                      '目標達成',
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildStatItem(
    BuildContext context,
    IconData icon,
    String value,
    String label,
  ) {
    return Column(
      children: [
        Icon(icon, color: Theme.of(context).primaryColor),
        const SizedBox(height: 4),
        Text(
          value,
          style: Theme.of(context).textTheme.subtitle1?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: Theme.of(context).textTheme.caption,
        ),
      ],
    );
  }

  Future<Map<String, dynamic>> _getDailyStats() async {
    final db = await DatabaseHelper.instance.database;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day).toIso8601String();
    
    final results = await db.rawQuery('''
      SELECT 
        COUNT(*) as count,
        SUM(durationMinutes) as totalMinutes
      FROM pomodoro_sessions
      WHERE date(startTime) = date(?)
    ''', [today]);
    
    int totalPomodoros = 0;
    int totalMinutes = 0;
    
    if (results.isNotEmpty) {
      totalPomodoros = results.first['count'] as int? ?? 0;
      totalMinutes = results.first['totalMinutes'] as int? ?? 0;
    }
    
    return {
      'totalPomodoros': totalPomodoros,
      'totalMinutes': totalMinutes,
      'targetPomodoros': 8, // 目標ポモドーロ数（設定から取得するよう改善可能）
    };
  }
}

// widgets/task_selection.dart - タスク選択ウィジェット
import 'package:flutter/material.dart';
import '../models/task.dart';

class TaskSelection extends StatefulWidget {
  final List<Task> tasks;
  final Function(Task) onTaskSelected;

  const TaskSelection({
    Key? key,
    required this.tasks,
    required this.onTaskSelected,
  }) : super(key: key);

  @override
  _TaskSelectionState createState() => _TaskSelectionState();
}

class _TaskSelectionState extends State<TaskSelection> {
  String _selectedCategory = 'すべて';
  Task? _selectedTask;

  @override
  Widget build(BuildContext context) {
    // カテゴリーリストを作成
    final categories = ['すべて', ...widget.tasks.map((e) => e.category).toSet()];
    
    // カテゴリーでフィルタリング
    final filteredTasks = _selectedCategory == 'すべて'
        ? widget.tasks
        : widget.tasks.where((task) => task.category == _selectedCategory).toList();

    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'タスクを選択',
              style: Theme.of(context).textTheme.headline6,
            ),
            const SizedBox(height: 8),
            
            // カテゴリー選択チップ
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                children: categories.map((category) {
                  return Padding(
                    padding: const EdgeInsets.only(right: 8.0),
                    child: ChoiceChip(
                      label: Text(category),
                      selected: _selectedCategory == category,
                      onSelected: (selected) {
                        if (selected) {
                          setState(() {
                            _selectedCategory = category;
                            _selectedTask = null;
                          });
                        }
                      },
                    ),
                  );
                }).toList(),
              ),
            ),
            
            const SizedBox(height: 16),
            
            // タスクリスト
            if (filteredTasks.isEmpty)
              const Center(
                child: Padding(
                  padding: EdgeInsets.all(16.0),
                  child: Text('タスクがありません。新しいタスクを追加してください。'),
                ),
              )
            else
              Column(
                children: filteredTasks.map((task) {
                  final isSelected = _selectedTask?.id == task.id;
                  final progress = task.estimatedPomodoros > 0
                      ? task.completedPomodoros / task.estimatedPomodoros
                      : 0.0;
                  
                  return Card(
                    elevation: isSelected ? 4 : 1,
                    color: isSelected ? Theme.of(context).primaryColor.withOpacity(0.1) : null,
                    margin: const EdgeInsets.only(bottom: 8.0),
                    child: InkWell(
                      onTap: () {
                        setState(() {
                          _selectedTask = task;
                        });
                        widget.onTaskSelected(task);
                      },
                      child: Padding(
                        padding: const EdgeInsets.all(12.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              children: [
                                Expanded(
                                  child: Text(
                                    task.name,
                                    style: TextStyle(
                                      fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                      fontSize: 16,
                                    ),
                                  ),
                                ),
                                Chip(
                                  label: Text(task.category),
                                  backgroundColor: Colors.grey[200],
                                ),
                              ],
                            ),
                            if (task.description.isNotEmpty) ...[
                              const SizedBox(height: 4),
                              Text(
                                task.description,
                                style: TextStyle(
                                  color: Colors.grey[700],
                                  fontSize: 14,
                                ),
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ],
                            const SizedBox(height: 8),
                            Row(
                              children: [
                                Expanded(
                                  child: LinearProgressIndicator(
                                    value: progress.clamp(0.0, 1.0),
                                    minHeight: 6,
                                    backgroundColor: Colors.grey[300],
                                  ),
                                ),
                                const SizedBox(width: 8),
                                Text(
                                  '${task.completedPomodoros}/${task.estimatedPomodoros}',
                                  style: const TextStyle(
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      ),
                    ),
                  );
                }).toList(),
              ),
          ],
        ),
      ),
    );
  }
}

// screens/tasks_screen.dart - タスク管理画面
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/task_provider.dart';
import '../models/task.dart';

class TasksScreen extends StatefulWidget {
  const TasksScreen({Key? key}) : super(key: key);

  @override
  _TasksScreenState createState() => _TasksScreenState();
}

class _TasksScreenState extends State<TasksScreen> {
  String _filter = 'all';
  String _searchQuery = '';
  final _searchController = TextEditingController();

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final taskProvider = Provider.of<TaskProvider>(context);
    
    // タスクをフィルタリング
    final filteredTasks = _filterTasks(taskProvider.tasks);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('タスク管理'),
        actions: [
          IconButton(
            icon: const Icon(Icons.search),
            onPressed: () {
              showSearch(
                context: context,
                delegate: TaskSearchDelegate(taskProvider.tasks),
              );
            },
          ),
        ],
      ),
      body: Column(
        children: [
          // フィルターチップ
          SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            padding: const EdgeInsets.symmetric(vertical: 8.0),
            child: Row(
              children: [
                const SizedBox(width: 8),
                FilterChip(
                  label: const Text('すべて'),
                  selected: _filter == 'all',
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _filter = 'all';
                      });
                    }
                  },
                ),
                const SizedBox(width: 8),
                FilterChip(
                  label: const Text('進行中'),
                  selected: _filter == 'in_progress',
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _filter = 'in_progress';
                      });
                    }
                  },
                ),
                const SizedBox(width: 8),
                FilterChip(
                  label: const Text('完了'),
                  selected: _filter == 'completed',
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _filter = 'completed';
                      });
                    }
                  },
                ),
              ],
            ),
          ),
          
          // 検索バー
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            child: TextField(
              controller: _searchController,
              decoration: InputDecoration(
                hintText: 'タスクを検索',
                prefixIcon: const Icon(Icons.search),
                suffixIcon: _searchQuery.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear),
                        onPressed: () {
                          setState(() {
                            _searchController.clear();
                            _searchQuery = '';
                          });
                        },
                      )
                    : null,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8.0),
                ),
              ),
              onChanged: (value) {
                setState(() {
                  _searchQuery = value;
                });
              },
            ),
          ),
          
          // タスクリスト
          Expanded(
            child: filteredTasks.isEmpty
                ? Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.task_alt,
                          size: 64,
                          color: Colors.grey[400],
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'タスクがありません',
                          style: TextStyle(
                            fontSize: 18,
                            color: Colors.grey[600],
                          ),
                        ),
                        const SizedBox(height: 8),
                        ElevatedButton.icon(
                          icon: const Icon(Icons.add),
                          label: const Text('新しいタスクを追加'),
                          onPressed: () => _showAddTaskDialog(context),
                        ),
                      ],
                    ),
                  )
                : ListView.builder(
                    itemCount: filteredTasks.length,
                    itemBuilder: (context, index) {
                      final task = filteredTasks[index];
                      return _buildTaskItem(context, task);
                    },
                  ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        child: const Icon(Icons.add),
        onPressed: () => _showAddTaskDialog(context),
      ),
    );
  }

  // タスク項目ウィジェット
  Widget _buildTaskItem(BuildContext context, Task task) {
    final progress = task.estimatedPomodoros > 0
        ? task.completedPomodoros / task.estimatedPomodoros
        : 0.0;
    
    return Dismissible(
      key: Key('task_${task.id}'),
      background: Container(
        color: Colors.red,
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.only(right: 20.0),
        child: const Icon(
          Icons.delete,
          color: Colors.white,
        ),
      ),
      direction: DismissDirection.endToStart,
      confirmDismiss: (direction) async {
        return await showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('確認'),
            content: Text('「${task.name}」を削除しますか？'),
            actions: [
              TextButton(
                child: const Text('キャンセル'),
                onPressed: () => Navigator.of(context).pop(false),
              ),
              TextButton(
                child: const Text('削除'),
                onPressed: () => Navigator.of(context).pop(true),
              ),
            ],
          ),
        );
      },
      onDismissed: (direction) {
        final taskProvider = Provider.of<TaskProvider>(context, listen: false);
        taskProvider.deleteTask(task.id!);
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('「${task.name}」を削除しました')),
        );
      },
      child: Card(
        margin: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 4.0),
        child: InkWell(
          onTap: () => _showTaskDetailDialog(context, task),
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        task.name,
                        style: const TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                    Chip(
                      label: Text(task.category),
                      backgroundColor: Colors.grey[200],
                    ),
                  ],
                ),
                if (task.description.isNotEmpty) ...[
                  const SizedBox(height: 4),
                  Text(
                    task.description,
                    style: TextStyle(
                      color: Colors.grey[700],
                      fontSize: 14,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: LinearProgressIndicator(
                        value: progress.clamp(0.0, 1.0),
                        minHeight: 6,
                        backgroundColor: Colors.grey[300],
                      ),
                    ),
                    const SizedBox(width: 8),
                    Text(
                      '${task.completedPomodoros}/${task.estimatedPomodoros}',
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(width: 16),
                    IconButton(
                      icon: const Icon(Icons.edit),
                      onPressed: () => _showEditTaskDialog(context, task),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  // タスクをフィルタリング
  List<Task> _filterTasks(List<Task> tasks) {
    // フィルター適用
    List<Task> result = [];
    
    switch (_filter) {
      case 'all':
        result = List.from(tasks);
        break;
      case 'in_progress':
        result = tasks
            .where((task) => task.completedPomodoros < task.estimatedPomodoros)
            .toList();
        break;
      case 'completed':
        result = tasks
            .where((task) => task.completedPomodoros >= task.estimatedPomodoros)
            .toList();
        break;
    }
    
    // 検索クエリ適用
    if (_searchQuery.isNotEmpty) {
      final query = _searchQuery.toLowerCase();
      result = result.where((task) {
        return task.name.toLowerCase().contains(query) ||
            task.description.toLowerCase().contains(query) ||
            task.category.toLowerCase().contains(query);
      }).toList();
    }
    
    // ソート：最新の更新順
    result.sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
    
    return result;
  }

  // タスク追加ダイアログ
  Future<void> _showAddTaskDialog(BuildContext context) async {
    final formKey = GlobalKey<FormState>();
    String name = '';
    String category = '';
    String description = '';
    int estimatedPomodoros = 1;
    
    return showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('新しいタスクを追加'),
          content: Form(
            key: formKey,
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextFormField(
                    decoration: const InputDecoration(
                      labelText: 'タスク名',
                      hintText: '例: 数学の演習問題を解く',
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'タスク名を入力してください';
                      }
                      return null;
                    },
                    onSaved: (value) {
                      name = value!;
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    decoration: const InputDecoration(
                      labelText: 'カテゴリー',
                      hintText: '例: 数学、英語、プログラミング',
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'カテゴリーを入力してください';
                      }
                      return null;
                    },
                    onSaved: (value) {
                      category = value!;
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    decoration: const InputDecoration(
                      labelText: '説明（任意）',
                      hintText: '例: 教科書p.45-50の問題',
                    ),
                    maxLines: 2,
                    onSaved: (value) {
                      description = value ?? '';
                    },
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      const Expanded(
                        child: Text('予定ポモドーロ数'),
                      ),
                      IconButton(
                        icon: const Icon(Icons.remove),
                        onPressed: () {
                          if (estimatedPomodoros > 1) {
                            setState(() {
                              estimatedPomodoros--;
                            });
                          }
                        },
                      ),
                      Text(
                        '$estimatedPomodoros',
                        style: const TextStyle(fontSize: 16),
                      ),
                      IconButton(
                        icon: const Icon(Icons.add),
                        onPressed: () {
                          setState(() {
                            estimatedPomodoros++;
                          });
                        },
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
          actions: [
            TextButton(
              child: const Text('キャンセル'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            ElevatedButton(
              child: const Text('追加'),
              onPressed: () {
                if (formKey.currentState!.validate()) {
                  formKey.currentState!.save();
                  
                  final taskProvider = Provider.of<TaskProvider>(context, listen: false);
                  
                  final newTask = Task(
                    name: name,
                    category: category,
                    description: description,
                    estimatedPomodoros: estimatedPomodoros,
                  );
                  
                  taskProvider.addTask(newTask);
                  
                  Navigator.of(context).pop();
                }
              },
            ),
          ],
        );
      },
    );
  }

  // タスク編集ダイアログ
  Future<void> _showEditTaskDialog(BuildContext context, Task task) async {
    final formKey = GlobalKey<FormState>();
    String name = task.name;
    String category = task.category;
    String description = task.description;
    int estimatedPomodoros = task.estimatedPomodoros;
    
    return showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('タスクを編集'),
          content: Form(
            key: formKey,
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextFormField(
                    decoration: const InputDecoration(
                      labelText: 'タスク名',
                    ),
                    initialValue: name,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'タスク名を入力してください';
                      }
                      return null;
                    },
                    onSaved: (value) {
                      name = value!;
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    decoration: const InputDecoration(
                      labelText: 'カテゴリー',
                    ),
                    initialValue: category,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'カテゴリーを入力してください';
                      }
                      return null;
                    },
                    onSaved: (value) {
                      category = value!;
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    decoration: const InputDecoration(
                      labelText: '説明（任意）',
                    ),
                    initialValue: description,
                    maxLines: 2,
                    onSaved: (value) {
                      description = value ?? '';
                    },
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      const Expanded(
                        child: Text('予定ポモドーロ数'),
                      ),
                      IconButton(
                        icon: const Icon(Icons.remove),
                        onPressed: () {
                          if (estimatedPomodoros > 1) {
                            setState(() {
                              estimatedPomodoros--;
                            });
                          }
                        },
                      ),
                      Text(
                        '$estimatedPomodoros',
                        style: const TextStyle(fontSize: 16),
                      ),
                      IconButton(
                        icon: const Icon(Icons.add),
                        onPressed: () {
                          setState(() {
                            estimatedPomodoros++;
                          });
                        },
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
          actions: [
            TextButton(
              child: const Text('キャンセル'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: const Text('削除'),
              style: TextButton.styleFrom(
                foregroundColor: Colors.red,
              ),
              onPressed: () {
                final taskProvider = Provider.of<TaskProvider>(context, listen: false);
                taskProvider.deleteTask(task.id!);
                Navigator.of(context).pop();
              },
            ),
            ElevatedButton(
              child: const Text('保存'),
              onPressed: () {
                if (formKey.currentState!.validate()) {
                  formKey.currentState!.save();
                  
                  final taskProvider = Provider.of<TaskProvider>(context, listen: false);
                  
                  final updatedTask = task.copyWith(
                    name: name,
                    category: category,
                    description: description,
                    estimatedPomodoros: estimatedPomodoros,
                    updatedAt: DateTime.now(),
                  );
                  
                  taskProvider.updateTask(updatedTask);
                  
                  Navigator.of(context).pop();
                }
              },
            ),
          ],
        );
      },
    );
  }

  // タスク詳細ダイアログ
  Future<void> _showTaskDetailDialog(BuildContext context, Task task) async {
    final progress = task.estimatedPomodoros > 0
        ? task.completedPomodoros / task.estimatedPomodoros
        : 0.0;
    
    return showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(task.name),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Chip(
                  label: Text(task.category),
                  backgroundColor: Colors.grey[200],
                ),
                const SizedBox(height: 16),
                if (task.description.isNotEmpty) ...[
                  const Text(
                    '説明:',
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(task.description),
                  const SizedBox(height: 16),
                ],
                const Text(
                  '進捗:',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                LinearProgressIndicator(
                  value: progress.clamp(0.0, 1.0),
                  minHeight: 10,
                  backgroundColor: Colors.grey[300],
                ),
                const SizedBox(height: 8),
                Text(
                  '${task.completedPomodoros} / ${task.estimatedPomodoros} ポモドーロ完了',
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                const Text(
                  '作成日:',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(_formatDateTime(task.createdAt)),
                const SizedBox(height: 8),
                const Text(
                  '最終更新:',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(_formatDateTime(task.updatedAt)),
              ],
            ),
          ),
          actions: [
            TextButton(
              child: const Text('閉じる'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            ElevatedButton.icon(
              icon: const Icon(Icons.edit),
              label: const Text('編集'),
              onPressed: () {
                Navigator.of(context).pop();
                _showEditTaskDialog(context, task);
              },
            ),
          ],
        );
      },
    );
  }

  // 日時のフォーマット
  String _formatDateTime(DateTime dateTime) {
    return '${dateTime.year}/${dateTime.month.toString().padLeft(2, '0')}/${dateTime.day.toString().padLeft(2, '0')} '
        '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }
}

// タスク検索デリゲート
class TaskSearchDelegate extends SearchDelegate<Task?> {
  final List<Task> tasks;

  TaskSearchDelegate(this.tasks);

  @override
  List<Widget> buildActions(BuildContext context) {
    return [
      IconButton(
        icon: const Icon(Icons.clear),
        onPressed: () {
          query = '';
        },
      ),
    ];
  }

  @override
  Widget buildLeading(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.arrow_back),
      onPressed: () {
        close(context, null);
      },
    );
  }

  @override
  Widget buildResults(BuildContext context) {
    return _buildSearchResults();
  }

  @override
  Widget buildSuggestions(BuildContext context) {
    return _buildSearchResults();
  }

  Widget _buildSearchResults() {
    if (query.isEmpty) {
      return Center(
        child: Text(
          '検索キーワードを入力してください',
          style: TextStyle(color: Colors.grey[600]),
        ),
      );
    }

    final results = tasks.where((task) {
      final queryLower = query.toLowerCase();
      return task.name.toLowerCase().contains(queryLower) ||
          task.description.toLowerCase().contains(queryLower) ||
          task.category.toLowerCase().contains(queryLower);
    }).toList();

    if (results.isEmpty) {
      return Center(
        child: Text(
          '「$query」に一致するタスクはありません',
          style: TextStyle(color: Colors.grey[600]),
        ),
      );
    }

    return ListView.builder(
      itemCount: results.length,
      itemBuilder: (context, index) {
        final task = results[index];
        return ListTile(
          title: Text(task.name),
          subtitle: Text(task.category),
          onTap: () {
            close(context, task);
          },
        );
      },
    );
  }
}

// providers/task_provider.dart - タスク管理のProvider
import 'package:flutter/material.dart';
import '../models/task.dart';
import '../services/database_helper.dart';

class TaskProvider with ChangeNotifier {
  List<Task> _tasks = [];
  
  List<Task> get tasks => _tasks;
  
  TaskProvider() {
    loadTasks();
  }
  
  Future<void> loadTasks() async {
    _tasks = await DatabaseHelper.instance.getTasks();
    notifyListeners();
  }
  
  Future<void> addTask(Task task) async {
    final id = await DatabaseHelper.instance.insertTask(task);
    final newTask = task.copyWith(id: id);
    _tasks.add(newTask);
    notifyListeners();
  }
  
  Future<void> updateTask(Task task) async {
    await DatabaseHelper.instance.updateTask(task);
    
    final index = _tasks.indexWhere((t) => t.id == task.id);
    if (index >= 0) {
      _tasks[index] = task;
      notifyListeners();
    }
  }
  
  Future<void> deleteTask(int id) async {
    await DatabaseHelper.instance.deleteTask(id);
    _tasks.removeWhere((task) => task.id == id);
    notifyListeners();
  }
  
  Future<void> incrementTaskPomodoro(int taskId) async {
    final index = _tasks.indexWhere((task) => task.id == taskId);
    
    if (index >= 0) {
      final task = _tasks[index];
      final updatedTask = task.copyWith(
        completedPomodoros: task.completedPomodoros + 1,
        updatedAt: DateTime.now(),
      );
      
      await DatabaseHelper.instance.updateTask(updatedTask);
      _tasks[index] = updatedTask;
      notifyListeners();
    }
  }
}

/*









































*/

// screens/statistics_screen.dart - 統計画面の実装
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../providers/task_provider.dart';
import '../services/database_helper.dart';
import '../models/pomodoro_session.dart';
import '../widgets/heat_map_calendar.dart';
import '../widgets/category_chart.dart';

class StatisticsScreen extends StatefulWidget {
  const StatisticsScreen({Key? key}) : super(key: key);

  @override
  _StatisticsScreenState createState() => _StatisticsScreenState();
}

class _StatisticsScreenState extends State<StatisticsScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 4, vsync: this);
  }
  
  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('学習統計'),
        bottom: TabBar(
          controller: _tabController,
          isScrollable: true,
          tabs: const [
            Tab(text: '日別'),
            Tab(text: '週別'),
            Tab(text: 'タスク別'),
            Tab(text: 'カレンダー'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: const [
          DailyStatisticsTab(),
          WeeklyStatisticsTab(),
          TaskStatisticsTab(),
          CalendarStatisticsTab(),
        ],
      ),
    );
  }
}

// 日別統計タブ
class DailyStatisticsTab extends StatelessWidget {
  const DailyStatisticsTab({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<List<Map<String, dynamic>>>(
      future: DatabaseHelper.instance.getDailyStatistics(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        
        if (snapshot.hasError) {
          return Center(child: Text('エラーが発生しました: ${snapshot.error}'));
        }
        
        final data = snapshot.data ?? [];
        
        if (data.isEmpty) {
          return const Center(child: Text('データがありません'));
        }
        
        // グラフ用のデータ
        final barGroups = data.asMap().entries.map((entry) {
          final index = entry.key;
          final item = entry.value;
          return BarChartGroupData(
            x: index,
            barRods: [
              BarChartRodData(
                toY: item['count'].toDouble(),
                color: Theme.of(context).primaryColor,
                width: 15,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(4),
                  topRight: Radius.circular(4),
                ),
              ),
            ],
          );
        }).toList();
        
        // 総計の計算
        final totalPomodoros = data.fold<int>(
          0, (sum, item) => sum + (item['count'] as int));
        final totalMinutes = data.fold<int>(
          0, (sum, item) => sum + (item['totalMinutes'] as int? ?? 0));
        final averagePomodoros = data.isEmpty 
          ? 0.0 
          : totalPomodoros / data.length;
        
        return Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // サマリーカード
              Card(
                elevation: 2,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceAround,
                    children: [
                      _buildStatColumn(
                        context, 
                        '$totalPomodoros', 
                        '合計ポモドーロ',
                        Icons.timer,
                      ),
                      _buildStatColumn(
                        context, 
                        '${totalMinutes ~/ 60}時間${totalMinutes % 60}分', 
                        '合計時間',
                        Icons.access_time,
                      ),
                      _buildStatColumn(
                        context, 
                        averagePomodoros.toStringAsFixed(1), 
                        '1日平均',
                        Icons.trending_up,
                      ),
                    ],
                  ),
                ),
              ),
              
              const SizedBox(height: 24),
              
              // 日別グラフ
              Expanded(
                child: Card(
                  elevation: 4,
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          '日別ポモドーロ完了数',
                          style: Theme.of(context).textTheme.headline6,
                        ),
                        const SizedBox(height: 16),
                        Expanded(
                          child: BarChart(
                            BarChartData(
                              alignment: BarChartAlignment.spaceAround,
                              maxY: data.map((e) => e['count'] as int).reduce(
                                (a, b) => a > b ? a : b) * 1.2,
                              barTouchData: BarTouchData(
                                enabled: true,
                                touchTooltipData: BarTouchTooltipData(
                                  tooltipBgColor: Colors.blueGrey,
                                  getTooltipItem: (group, groupIndex, rod, rodIndex) {
                                    final dateStr = data[groupIndex]['date'] as String;
                                    return BarTooltipItem(
                                      '$dateStr\n',
                                      const TextStyle(color: Colors.white),
                                      children: <TextSpan>[
                                        TextSpan(
                                          text: '${rod.toY.round()} ポモドーロ',
                                          style: const TextStyle(
                                            color: Colors.yellow,
                                            fontWeight: FontWeight.bold,
                                          ),
                                        ),
                                      ],
                                    );
                                  },
                                ),
                              ),
                              titlesData: FlTitlesData(
                                show: true,
                                bottomTitles: AxisTitles(
                                  sideTitles: SideTitles(
                                    showTitles: true,
                                    getTitlesWidget: (value, meta) {
                                      final index = value.toInt();
                                      if (index >= 0 && index < data.length) {
                                        final date = data[index]['date'] as String;
                                        return Padding(
                                          padding: const EdgeInsets.only(top: 8.0),
                                          child: Text(
                                            date.substring(5), // 月/日のみ表示
                                            style: const TextStyle(
                                              fontSize: 12,
                                              fontWeight: FontWeight.bold,
                                            ),
                                          ),
                                        );
                                      }
                                      return const Text('');
                                    },
                                  ),
                                ),
                                leftTitles: AxisTitles(
                                  sideTitles: SideTitles(
                                    showTitles: true,
                                    reservedSize: 30,
                                    getTitlesWidget: (value, meta) {
                                      if (value == 0) {
                                        return const Text('0');
                                      }
                                      return Text(value.toInt().toString());
                                    },
                                  ),
                                ),
                                topTitles: AxisTitles(
                                  sideTitles: SideTitles(showTitles: false),
                                ),
                                rightTitles: AxisTitles(
                                  sideTitles: SideTitles(showTitles: false),
                                ),
                              ),
                              borderData: FlBorderData(show: false),
                              barGroups: barGroups,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
              
              const SizedBox(height: 16),
              
              // 詳細データテーブル
              Card(
                elevation: 2,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        '詳細データ',
                        style: Theme.of(context).textTheme.subtitle1,
                      ),
                      const SizedBox(height: 8),
                      SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                        child: DataTable(
                          columns: const [
                            DataColumn(label: Text('日付')),
                            DataColumn(label: Text('ポモドーロ数')),
                            DataColumn(label: Text('学習時間')),
                          ],
                          rows: data.map((item) {
                            final minutes = item['totalMinutes'] as int? ?? 0;
                            final hours = minutes ~/ 60;
                            final mins = minutes % 60;
                            
                            return DataRow(
                              cells: [
                                DataCell(Text(item['date'] as String)),
                                DataCell(Text('${item['count']} 回')),
                                DataCell(Text('$hours時間$mins分')),
                              ],
                            );
                          }).toList(),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
  
  Widget _buildStatColumn(
    BuildContext context, 
    String value, 
    String label, 
    IconData icon
  ) {
    return Column(
      children: [
        Icon(icon, color: Theme.of(context).primaryColor),
        const SizedBox(height: 8),
        Text(
          value,
          style: Theme.of(context).textTheme.headline6,
        ),
        Text(
          label,
          style: Theme.of(context).textTheme.caption,
        ),
      ],
    );
  }
}

// 週別統計タブ
class WeeklyStatisticsTab extends StatelessWidget {
  const WeeklyStatisticsTab({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<List<Map<String, dynamic>>>(
      future: DatabaseHelper.instance.getWeeklyStatistics(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        
        if (snapshot.hasError) {
          return Center(child: Text('エラーが発生しました: ${snapshot.error}'));
        }
        
        final data = snapshot.data ?? [];
        
        if (data.isEmpty) {
          return const Center(child: Text('データがありません'));
        }
        
        // 週の表示名を作成
        final formattedData = data.map((item) {
          final week = item['week'] as String;
          final parts = week.split('-');
          final year = parts[0];
          final weekNum = parts[1];
          
          // 週の最初の日を計算
          final firstDay = _getFirstDayOfWeek(int.parse(year), int.parse(weekNum));
          final displayWeek = DateFormat('MM/dd').format(firstDay);
          
          return {
            ...item,
            'displayWeek': displayWeek,
          };
        }).toList();
        
        // グラフ用データ
        final barGroups = formattedData.asMap().entries.map((entry) {
          final index = entry.key;
          final item = entry.value;
          return BarChartGroupData(
            x: index,
            barRods: [
              BarChartRodData(
                toY: item['count'].toDouble(),
                color: Colors.blue,
                width: 20,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(4),
                  topRight: Radius.circular(4),
                ),
              ),
            ],
          );
        }).toList();
        
        // 総計と平均の計算
        final totalPomodoros = formattedData.fold<int>(
          0, (sum, item) => sum + (item['count'] as int));
        final totalMinutes = formattedData.fold<int>(
          0, (sum, item) => sum + (item['totalMinutes'] as int? ?? 0));
        final averagePomodoros = formattedData.isEmpty 
          ? 0.0 
          : totalPomodoros / formattedData.length;
        
        return Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // サマリーカード
              Card(
                elevation: 2,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceAround,
                    children: [
                      _buildStatColumn(
                        context, 
                        '$totalPomodoros', 
                        '週間合計',
                        Icons.timer,
                      ),
                      _buildStatColumn(
                        context, 
                        '${totalMinutes ~/ 60}時間', 
                        '合計時間',
                        Icons.access_time,
                      ),
                      _buildStatColumn(
                        context, 
                        averagePomodoros.toStringAsFixed(1), 
                        '週平均',
                        Icons.trending_up,
                      ),
                    ],
                  ),
                ),
              ),
              
              const SizedBox(height: 24),
              
              // 週別グラフ
              Expanded(
                child: Card(
                  elevation: 4,
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          '週別ポモドーロ完了数',
                          style: Theme.of(context).textTheme.headline6,
                        ),
                        const SizedBox(height: 16),
                        Expanded(
                          child: BarChart(
                            BarChartData(
                              alignment: BarChartAlignment.spaceAround,
                              maxY: formattedData.map((e) => e['count'] as int).reduce(
                                (a, b) => a > b ? a : b) * 1.2,
                              barTouchData: BarTouchData(
                                enabled: true,
                                touchTooltipData: BarTouchTooltipData(
                                  tooltipBgColor: Colors.blueGrey,
                                  getTooltipItem: (group, groupIndex, rod, rodIndex) {
                                    return BarTooltipItem(
                                      '${formattedData[groupIndex]['displayWeek']}週\n',
                                      const TextStyle(color: Colors.white),
                                      children: <TextSpan>[
                                        TextSpan(
                                          text: '${rod.toY.round()} ポモドーロ',
                                          style: const TextStyle(
                                            color: Colors.yellow,
                                            fontWeight: FontWeight.bold,
                                          ),
                                        ),
                                      ],
                                    );
                                  },
                                ),
                              ),
                              titlesData: FlTitlesData(
                                show: true,
                                bottomTitles: AxisTitles(
                                  sideTitles: SideTitles(
                                    showTitles: true,
                                    getTitlesWidget: (value, meta) {
                                      final index = value.toInt();
                                      if (index >= 0 && index < formattedData.length) {
                                        return Padding(
                                          padding: const EdgeInsets.only(top: 8.0),
                                          child: Text(
                                            formattedData[index]['displayWeek'] as String,
                                            style: const TextStyle(
                                              fontSize: 12,
                                              fontWeight: FontWeight.bold,
                                            ),
                                          ),
                                        );
                                      }
                                      return const Text('');
                                    },
                                  ),
                                ),
                                leftTitles: AxisTitles(
                                  sideTitles: SideTitles(
                                    showTitles: true,
                                    reservedSize: 30,
                                    getTitlesWidget: (value, meta) {
                                      if (value == 0) {
                                        return const Text('0');
                                      }
                                      return Text(value.toInt().toString());
                                    },
                                  ),
                                ),
                                topTitles: AxisTitles(
                                  sideTitles: SideTitles(showTitles: false),
                                ),
                                rightTitles: AxisTitles(
                                  sideTitles: SideTitles(showTitles: false),
                                ),
                              ),
                              borderData: FlBorderData(show: false),
                              barGroups: barGroups,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
              
              const SizedBox(height: 16),
              
              // 詳細データテーブル
              Card(
                elevation: 2,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        '詳細データ',
                        style: Theme.of(context).textTheme.subtitle1,
                      ),
                      const SizedBox(height: 8),
                      SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                        child: DataTable(
                          columns: const [
                            DataColumn(label: Text('週')),
                            DataColumn(label: Text('ポモドーロ数')),
                            DataColumn(label: Text('学習時間')),
                          ],
                          rows: formattedData.map((item) {
                            final minutes = item['totalMinutes'] as int? ?? 0;
                            final hours = minutes ~/ 60;
                            final mins = minutes % 60;
                            
                            return DataRow(
                              cells: [
                                DataCell(Text('${item['displayWeek']}週')),
                                DataCell(Text('${item['count']} 回')),
                                DataCell(Text('$hours時間$mins分')),
                              ],
                            );
                          }).toList(),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
  
  // ISO週番号から週の最初の日（月曜日）の日付を計算
  DateTime _getFirstDayOfWeek(int year, int weekNumber) {
    // 1月4日は常に第1週に含まれる
    final jan4 = DateTime(year, 1, 4);
    // 1月4日の曜日（月曜日が1、日曜日が7）
    final jan4Weekday = jan4.weekday;
    // 第1週の最初の日（月曜日）
    final firstMonday = jan4.subtract(Duration(days: jan4Weekday - 1));
    // 求める週の最初の日
    return firstMonday.add(Duration(days: (weekNumber - 1) * 7));
  }
  
  Widget _buildStatColumn(
    BuildContext context, 
    String value, 
    String label, 
    IconData icon
  ) {
    return Column(
      children: [
        Icon(icon, color: Colors.blue),
        const SizedBox(height: 8),
        Text(
          value,
          style: Theme.of(context).textTheme.headline6,
        ),
        Text(
          label,
          style: Theme.of(context).textTheme.caption,
        ),
      ],
    );
  }
}

// タスク別統計タブ
class TaskStatisticsTab extends StatelessWidget {
  const TaskStatisticsTab({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<List<Map<String, dynamic>>>(
      future: DatabaseHelper.instance.getTaskStatistics(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        
        if (snapshot.hasError) {
          return Center(child: Text('エラーが発生しました: ${snapshot.error}'));
        }
        
        final taskData = snapshot.data ?? [];
        
        if (taskData.isEmpty) {
          return const Center(child: Text('データがありません'));
        }
        
        // カテゴリ別データを取得
        return FutureBuilder<List<Map<String, dynamic>>>(
          future: DatabaseHelper.instance.getCategoryStatistics(),
          builder: (context, categorySnapshot) {
            if (categorySnapshot.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator());
            }
            
            final categoryData = categorySnapshot.data ?? [];
            
            // カテゴリ円グラフ用データ
            final pieData = categoryData.map((item) {
              final category = item['category'] as String? ?? 'その他';
              final sessionCount = item['sessionCount'] as int? ?? 0;
              
              return PieChartSectionData(
                value: sessionCount.toDouble(),
                title: '$category\n$sessionCount',
                radius: 100,
                titleStyle: const TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
                color: _getCategoryColor(category),
              );
            }).toList();
            
            return Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // カテゴリ別円グラフ
                  Card(
                    elevation: 4,
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'カテゴリ別学習時間',
                            style: Theme.of(context).textTheme.headline6,
                          ),
                          const SizedBox(height: 16),
                          SizedBox(
                            height: 220,
                            child: categoryData.isEmpty
                                ? const Center(child: Text('データがありません'))
                                : PieChart(
                                    PieChartData(
                                      sections: pieData,
                                      centerSpaceRadius: 0,
                                      sectionsSpace: 2,
                                      borderData: FlBorderData(show: false),
                                    ),
                                  ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  
                  const SizedBox(height: 16),
                  
                  // タスク別詳細
                  Expanded(
                    child: Card(
                      elevation: 2,
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'タスク別詳細',
                              style: Theme.of(context).textTheme.subtitle1,
                            ),
                            const SizedBox(height: 8),
                            Expanded(
                              child: taskData.isEmpty
                                  ? const Center(child: Text('データがありません'))
                                  : ListView.builder(
                                      itemCount: taskData.length,
                                      itemBuilder: (context, index) {
                                        final task = taskData[index];
                                        final name = task['name'] as String? ?? '';
                                        final category = task['category'] as String? ?? '';
                                        final sessionCount = task['sessionCount'] as int? ?? 0;
                                        final totalMinutes = task['totalMinutes'] as int? ?? 0;
                                        final hours = totalMinutes ~/ 60;
                                        final minutes = totalMinutes % 60;
                                        
                                        return ListTile(
                                          title: Text(name),
                                          subtitle: Text(category),
                                          trailing: Text(
                                            '$sessionCount回 ($hours時間$minutes分)',
                                            style: const TextStyle(
                                              fontWeight: FontWeight.bold,
                                            ),
                                          ),
                                          leading: CircleAvatar(
                                            backgroundColor: _getCategoryColor(category),
                                            child: Text(
                                              name.isNotEmpty ? name[0] : '?',
                                              style: const TextStyle(color: Colors.white),
                                            ),
                                          ),
                                        );
                                      },
                                    ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }
  
  // カテゴリ名に応じた色を返す
  Color _getCategoryColor(String category) {
    // カテゴリ名のハッシュ値に基づいて色を生成
    final hashCode = category.hashCode;
    
    // 定義済みの色リスト
    const colors = [
      Colors.red,
      Colors.blue,
      Colors.green,
      Colors.orange,
      Colors.purple,
      Colors.teal,
      Colors.indigo,
      Colors.pink,
      Colors.amber,
      Colors.cyan,
    ];
    
    return colors[hashCode % colors.length];
  }
}

// カレンダー統計タブ
class CalendarStatisticsTab extends StatelessWidget {
  const CalendarStatisticsTab({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // 6か月分のデータを取得
    final now = DateTime.now();
    final sixMonthsAgo = DateTime(now.year, now.month - 5, 1);
    
    return FutureBuilder<List<PomodoroSession>>(
      future: DatabaseHelper.instance.getPomodoroSessions(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        
        if (snapshot.hasError) {
          return Center(child: Text('エラーが発生しました: ${snapshot.error}'));
        }
        
        final sessions = snapshot.data ?? [];
        
        // 日付ごとのセッション数を集計
        final Map<DateTime, int> dailyCounts = {};
        for (final session in sessions) {
          final date = DateTime(
            session.startTime.year,
            session.startTime.month,
            session.startTime.day,
          );
          
          dailyCounts[date] = (dailyCounts[date] ?? 0) + 1;
        }
        
        return Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // ヒートマップカレンダー
              Text(
                'ポモドーロ達成カレンダー',
                style: Theme.of(context).textTheme.headline6,
              ),
              const SizedBox(height: 16),
              Expanded(
                child: Card(
                  elevation: 4,
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: HeatMapCalendar(
                      startDate: sixMonthsAgo,
                      endDate: now,
                      dailyCounts: dailyCounts,
                      colorMode: ColorMode.COLOR,
                      monthLabels: const [
                        '1月', '2月', '3月', '4月', '5月', '6月',
                        '7月', '8月', '9月', '10月', '11月', '12月'
                      ],
                      weekLabels: const ['月', '火', '水', '木', '金', '土', '日'],
                    ),
                  ),
                ),
              ),
              
              const SizedBox(height: 16),
              
              // 最近の連続記録
              Card(
                elevation: 2,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        '達成記録',
                        style: Theme.of(context).textTheme.subtitle1,
                      ),
                      const SizedBox(height: 8),
                      _buildStreakSummary(context, dailyCounts),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
  
  // 連続記録サマリーを構築
  Widget _buildStreakSummary(BuildContext context, Map<DateTime, int> dailyCounts) {
    // 記録のある日の一覧を取得
    final recordDays = dailyCounts.keys.toList()
      ..sort((a, b) => b.compareTo(a)); // 日付の降順にソート
    
    if (recordDays.isEmpty) {
      return const Text('まだ記録がありません');
    }
    
    // 最新の記録日
    final lastRecordDate = recordDays.first;
    
    // 今日の日付
    final today = DateTime(
      DateTime.now().year,
      DateTime.now().month,
      DateTime.now().day,
    );
    
    // 最新の記録が今日かどうか
    final isToday = lastRecordDate.isAtSameMomentAs(today);
    
    // 現在の連続日数を計算
    int currentStreak = 0;
    
    if (isToday) {
      // 今日から遡って連続日数をカウント
      currentStreak = 1;
      var checkDate = today.subtract(const Duration(days: 1));
      
      while (dailyCounts.containsKey(checkDate)) {
        currentStreak++;
        checkDate = checkDate.subtract(const Duration(days: 1));
      }
    } else {
      // 最新の記録から連続日数をカウント
      DateTime? checkDate;
      for (int i = 0; i < recordDays.length - 1; i++) {
        if (i == 0) {
          checkDate = recordDays[i];
          currentStreak = 1;
        } else {
          final nextDate = recordDays[i];
          final diff = checkDate!.difference(nextDate).inDays;
          
          if (diff == 1) {
            currentStreak++;
            checkDate = nextDate;
          } else {
            break;
          }
        }
      }
    }
    
    // 最長の連続記録を計算
    int longestStreak = 0;
    int currentLongestStreak = 0;
    DateTime? prevDate;
    
    for (final date in recordDays) {
      if (prevDate == null) {
        currentLongestStreak = 1;
      } else {
        final diff = prevDate.difference(date).inDays;
        
        if (diff == 1) {
          currentLongestStreak++;
        } else {
          currentLongestStreak = 1;
        }
      }
      
      if (currentLongestStreak > longestStreak) {
        longestStreak = currentLongestStreak;
      }
      
      prevDate = date;
    }
    
    // 総学習日数
    final totalDays = recordDays.length;
    
    return Column(
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            _buildStreakItem(
              context,
              '$currentStreak日',
              '現在の連続記録',
              Icons.local_fire_department,
              Colors.orange,
            ),
            _buildStreakItem(
              context,
              '$longestStreak日',
              '最長連続記録',
              Icons.emoji_events,
              Colors.amber,
            ),
            _buildStreakItem(
              context,
              '$totalDays日',
              '合計学習日数',
              Icons.calendar_today,
              Colors.blue,
            ),
          ],
        ),
        const SizedBox(height: 16),
        if (isToday) ...[
          const LinearProgressIndicator(
            value: 1.0,
            minHeight: 10,
            backgroundColor: Colors.grey,
            valueColor: AlwaysStoppedAnimation<Color>(Colors.green),
          ),
          const SizedBox(height: 8),
          Text(
            '今日も学習を完了しました！明日も続けましょう。',
            style: TextStyle(
              color: Colors.green[700],
              fontWeight: FontWeight.bold,
            ),
            textAlign: TextAlign.center,
          ),
        ] else ...[
          const LinearProgressIndicator(
            value: 0.0,
            minHeight: 10,
            backgroundColor: Colors.grey,
          ),
          const SizedBox(height: 8),
          Text(
            '今日はまだポモドーロを完了していません。今すぐ始めましょう！',
            style: TextStyle(
              color: Colors.grey[700],
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ],
    );
  }
  
  Widget _buildStreakItem(
    BuildContext context, 
    String value, 
    String label, 
    IconData icon,
    Color color,
  ) {
    return Column(
      children: [
        Icon(icon, color: color, size: 32),
        const SizedBox(height: 8),
        Text(
          value,
          style: Theme.of(context).textTheme.headline6?.copyWith(
            color: color,
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: Theme.of(context).textTheme.caption,
        ),
      ],
    );
  }
}

// widgets/heat_map_calendar.dart - ヒートマップカレンダーウィジェット
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

enum ColorMode {
  COLOR,
  OPACITY,
}

class HeatMapCalendar extends StatelessWidget {
  final DateTime startDate;
  final DateTime endDate;
  final Map<DateTime, int> dailyCounts;
  final ColorMode colorMode;
  final List<String> monthLabels;
  final List<String> weekLabels;
  
  const HeatMapCalendar({
    Key? key,
    required this.startDate,
    required this.endDate,
    required this.dailyCounts,
    this.colorMode = ColorMode.OPACITY,
    this.monthLabels = const [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ],
    this.weekLabels = const ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // 最大セッション数を取得
    final maxCount = dailyCounts.isEmpty
        ? 1
        : dailyCounts.values.reduce((max, value) => max > value ? max : value);
    
    // 表示する月のリストを生成
    final monthList = _generateMonthList();
    
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // 凡例
          Padding(
            padding: const EdgeInsets.only(bottom: 8.0, left: 40.0),
            child: Row(
              children: [
                const Text('少'),
                const SizedBox(width: 4),
                for (int i = 0; i < 5; i++)
                  Container(
                    width: 15,
                    height: 15,
                    margin: const EdgeInsets.symmetric(horizontal: 2),
                    color: _getColor(i * (maxCount / 4).ceil(), maxCount),
                  ),
                const SizedBox(width: 4),
                const Text('多'),
              ],
            ),
          ),
          
          // 曜日ラベル
          Padding(
            padding: const EdgeInsets.only(left: 40.0),
            child: Row(
              children: [
                const SizedBox(width: 2),
                ...List.generate(7, (index) {
                  return SizedBox(
                    width: 15,
                    child: Text(
                      weekLabels[index],
                      style: TextStyle(
                        fontSize: 10,
                        color: Colors.grey[600],
                      ),
                      textAlign: TextAlign.center,
                    ),
                  );
                }),
              ],
            ),
          ),
          
          const SizedBox(height: 4),
          
          // 各月のヒートマップ
          for (final month in monthList)
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // 月ラベル
                SizedBox(
                  width: 40,
                  child: Text(
                    monthLabels[month.month - 1],
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey[700],
                    ),
                  ),
                ),
                
                // 該当月のカレンダーグリッド
                _buildMonthGrid(month, maxCount),
              ],
            ),
        ],
      ),
    );
  }
  
  // 表示する月のリストを生成
  List<DateTime> _generateMonthList() {
    final result = <DateTime>[];
    
    // 表示開始月
    DateTime currentMonth = DateTime(startDate.year, startDate.month, 1);
    
    // 表示終了月
    final lastMonth = DateTime(endDate.year, endDate.month, 1);
    
    while (!currentMonth.isAfter(lastMonth)) {
      result.add(currentMonth);
      currentMonth = DateTime(currentMonth.year, currentMonth.month + 1, 1);
    }
    
    return result;
  }
  
  // 月のグリッドを構築
  Widget _buildMonthGrid(DateTime month, int maxCount) {
    // 月の初日
    final firstDayOfMonth = DateTime(month.year, month.month, 1);
    
    // 月の最終日
    final lastDayOfMonth = DateTime(month.year, month.month + 1, 0);
    
    // 初日の曜日（0: 月曜, 6: 日曜）
    final firstWeekday = firstDayOfMonth.weekday - 1;
    
    // カレンダーに表示する日数（前月の残りも含む）
    final daysInGrid = lastDayOfMonth.day + firstWeekday;
    
    // 週数
    final weeksCount = (daysInGrid / 7).ceil();
    
    return Column(
      children: List.generate(weeksCount, (weekIndex) {
        return Row(
          children: List.generate(7, (dayIndex) {
            final dayOffset = weekIndex * 7 + dayIndex - firstWeekday;
            
            if (dayOffset < 0 || dayOffset >= lastDayOfMonth.day) {
              // 前月または翌月のセル
              return const SizedBox(width: 15, height: 15);
            }
            
            // カレンダーの日付
            final date = DateTime(month.year, month.month, dayOffset + 1);
            
            // 当日のセッション数
            final count = dailyCounts[date] ?? 0;
            
            // 色を取得
            final color = _getColor(count, maxCount);
            
            return Container(
              width: 15,
              height: 15,
              margin: const EdgeInsets.all(1),
              decoration: BoxDecoration(
                color: color,
                borderRadius: BorderRadius.circular(2),
              ),
              child: Tooltip(
                message: '${DateFormat('yyyy/MM/dd').format(date)}: $count ポモドーロ',
                child: const SizedBox(),
              ),
            );
          }),
        );
      }),
    );
  }
  
  // 値に応じた色を取得
  Color _getColor(int count, int maxCount) {
    if (count == 0) {
      return Colors.grey[300]!;
    }
    
    if (colorMode == ColorMode.OPACITY) {
      // 透明度モード（緑色の濃淡）
      final opacity = count / maxCount;
      return Colors.green.withOpacity(0.2 + opacity * 0.8);
    } else {
      // カラーモード（青→緑→黄→赤）
      if (count <= maxCount * 0.25) {
        return Colors.blue[300]!;
      } else if (count <= maxCount * 0.5) {
        return Colors.green[400]!;
      } else if (count <= maxCount * 0.75) {
        return Colors.amber[500]!;
      } else {
        return Colors.red[400]!;
      }
    }
  }
}

// widgets/category_chart.dart - カテゴリグラフウィジェット
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';

class CategoryChart extends StatelessWidget {
  final List<Map<String, dynamic>> categoryData;
  
  const CategoryChart({
    Key? key,
    required this.categoryData,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    if (categoryData.isEmpty) {
      return const Center(child: Text('データがありません'));
    }
    
    // 合計セッション数
    final totalSessions = categoryData.fold<int>(
      0, (sum, item) => sum + (item['sessionCount'] as int? ?? 0));
    
    // 円グラフのセクションデータを作成
    final sections = <PieChartSectionData>[];
    
    for (int i = 0; i < categoryData.length; i++) {
      final item = categoryData[i];
      final category = item['category'] as String? ?? 'その他';
      final sessionCount = item['sessionCount'] as int? ?? 0;
      final percentage = sessionCount / totalSessions * 100;
      
      sections.add(
        PieChartSectionData(
          color: _getCategoryColor(i),
          value: sessionCount.toDouble(),
          title: '$category\n${percentage.toStringAsFixed(1)}%',
          radius: 100,
          titleStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.bold,
            color: Colors.white,
          ),
        ),
      );
    }
    
    return Column(
      children: [
        SizedBox(
          height: 200,
          child: PieChart(
            PieChartData(
              sections: sections,
              centerSpaceRadius: 0,
              sectionsSpace: 2,
              borderData: FlBorderData(show: false),
            ),
          ),
        ),
        const SizedBox(height: 16),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: categoryData.asMap().entries.map((entry) {
            final index = entry.key;
            final item = entry.value;
            final category = item['category'] as String? ?? 'その他';
            final sessionCount = item['sessionCount'] as int? ?? 0;
            final totalMinutes = item['totalMinutes'] as int? ?? 0;
            final hours = totalMinutes ~/ 60;
            final minutes = totalMinutes % 60;
            
            return Chip(
              avatar: CircleAvatar(
                backgroundColor: _getCategoryColor(index),
                radius: 8,
              ),
              label: Text(
                '$category: $sessionCount回 ($hours時間$minutes分)',
                style: const TextStyle(fontSize: 12),
              ),
              backgroundColor: Colors.grey[200],
            );
          }).toList(),
        ),
      ],
    );
  }
  
  // カテゴリインデックスに基づく色を返す
  Color _getCategoryColor(int index) {
    final colors = [
      Colors.blue,
      Colors.red,
      Colors.green,
      Colors.orange,
      Colors.purple,
      Colors.teal,
      Colors.pink,
      Colors.amber,
      Colors.indigo,
      Colors.cyan,
    ];
    
    return colors[index % colors.length];
  }
}

/*





































*/

// pubspec.yaml - プロジェクト設定ファイル
name: pomodoro_app
description: ポモドーロタイマーと学習管理アプリ

# アプリのバージョン
version: 1.0.0+1

environment:
  sdk: ">=2.17.0 <3.0.0"

dependencies:
  flutter:
    sdk: flutter
  
  # UI関連
  cupertino_icons: ^1.0.5
  fl_chart: ^0.55.0
  percent_indicator: ^4.2.2
  
  # 状態管理
  provider: ^6.0.3
  
  # データベース
  sqflite: ^2.0.3
  path: ^1.8.1
  shared_preferences: ^2.0.15
  
  # Windows機能アクセス
  win32: ^3.0.0
  ffi: ^2.0.1
  
  # その他のユーティリティ
  intl: ^0.17.0
  url_launcher: ^6.1.5
  file_picker: ^5.0.1
  http: ^0.13.5
  flutter_local_notifications: ^9.7.0
  
  # OSプラットフォーム検出
  platform: ^3.1.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^2.0.1
  
  # アプリアイコン生成
  flutter_launcher_icons: ^0.10.0
  
  # スプラッシュスクリーン生成
  flutter_native_splash: ^2.2.8

# アプリアイコン設定
flutter_icons:
  android: "launcher_icon"
  ios: true
  image_path: "assets/icon/icon.png"
  adaptive_icon_background: "#FFFFFF"
  adaptive_icon_foreground: "assets/icon/icon_foreground.png"

# スプラッシュスクリーン設定
flutter_native_splash:
  color: "#FFFFFF"
  image: "assets/icon/splash.png"
  android: true
  ios: true

flutter:
  uses-material-design: true
  
  # アセットファイル
  assets:
    - assets/images/
    - assets/icon/
    - assets/sounds/
  
  # フォント設定
  fonts:
    - family: NotoSansJP
      fonts:
        - asset: assets/fonts/NotoSansJP-Regular.otf
        - asset: assets/fonts/NotoSansJP-Bold.otf
          weight: 700

// android/app/src/main/AndroidManifest.xml - Androidマニフェスト設定
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.pomodoro_app">

    <!-- インターネット接続許可 -->
    <uses-permission android:name="android.permission.INTERNET" />
    <!-- 通知許可 -->
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.VIBRATE" />
    
    <application
        android:name="${applicationName}"
        android:icon="@mipmap/launcher_icon"
        android:label="ポモドーロ学習管理">
        <activity
            android:name=".MainActivity"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:exported="true"
            android:hardwareAccelerated="true"
            android:launchMode="singleTop"
            android:theme="@style/LaunchTheme"
            android:windowSoftInputMode="adjustResize">
            
            <meta-data
                android:name="io.flutter.embedding.android.NormalTheme"
                android:resource="@style/NormalTheme" />
            
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            
            <!-- TickTick認証用のカスタムスキーム -->
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <data
                    android:scheme="com.example.pomodoro"
                    android:host="oauth" />
            </intent-filter>
        </activity>
        
        <!-- Flutter用メタデータ -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
        
        <!-- 通知レシーバー -->
        <receiver android:name="com.dexterous.flutterlocalnotifications.ScheduledNotificationBootReceiver">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
                <action android:name="android.intent.action.MY_PACKAGE_REPLACED" />
            </intent-filter>
        </receiver>
        <receiver android:name="com.dexterous.flutterlocalnotifications.ScheduledNotificationReceiver" />
    </application>
</manifest>

// ios/Runner/Info.plist - iOS設定ファイル
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>ポモドーロ学習管理</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>pomodoro_app</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UIViewControllerBasedStatusBarAppearance</key>
	<false/>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
	
	<!-- TickTick認証用のカスタムURLスキーム -->
	<key>CFBundleURLTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>CFBundleURLName</key>
			<string>com.example.pomodoro</string>
			<key>CFBundleURLSchemes</key>
			<array>
				<string>com.example.pomodoro</string>
			</array>
		</dict>
	</array>
</dict>
</plist>

// windows/runner/main.cpp - Windows対応設定
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // アプリケーション名
  const std::wstring app_name = L"ポモドーロ学習管理";

  // DartプロジェクトのV8スナップショットデータを見つける
  // 実行ファイルと同じディレクトリにあることを前提とする
  std::wstring executable_path = GetExecutablePath();
  std::filesystem::path executable_directory = std::filesystem::path(executable_path).parent_path();
  std::string data_directory_path = executable_directory.string() + "\\data";
  std::string icu_data_path = executable_directory.string() + "\\icudtl.dat";

  // プロジェクト設定
  flutter::DartProject project(executable_directory);
  project.set_dart_entrypoint_arguments({});

  // Windowの作成
  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.CreateAndShow(app_name.c_str(), origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  // Windowsメッセージループ
  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}

// services/notification_service.dart - 通知サービス実装
import 'package:flutter_local_notifications/flutter_local_notifications.dart';

class NotificationService {
  static final NotificationService _instance = NotificationService._internal();
  factory NotificationService() => _instance;
  
  NotificationService._internal();
  
  final FlutterLocalNotificationsPlugin _flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();
      
  // 通知初期化
  Future<void> init() async {
    const AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('@mipmap/launcher_icon');
        
    const IOSInitializationSettings initializationSettingsIOS =
        IOSInitializationSettings(
      requestAlertPermission: true,
      requestBadgePermission: true,
      requestSoundPermission: true,
    );
    
    const InitializationSettings initializationSettings = InitializationSettings(
      android: initializationSettingsAndroid,
      iOS: initializationSettingsIOS,
    );
    
    await _flutterLocalNotificationsPlugin.initialize(
      initializationSettings,
    );
  }
  
  // 通知を表示
  Future<void> showNotification(String title, String body) async {
    const AndroidNotificationDetails androidPlatformChannelSpecifics =
        AndroidNotificationDetails(
      'pomodoro_channel',
      'ポモドーロ通知',
      channelDescription: 'ポモドーロタイマーの通知チャンネル',
      importance: Importance.max,
      priority: Priority.high,
      showWhen: true,
    );
    
    const IOSNotificationDetails iOSPlatformChannelSpecifics =
        IOSNotificationDetails(
      presentAlert: true,
      presentBadge: true,
      presentSound: true,
    );
    
    const NotificationDetails platformChannelSpecifics = NotificationDetails(
      android: androidPlatformChannelSpecifics,
      iOS: iOSPlatformChannelSpecifics,
    );
    
    await _flutterLocalNotificationsPlugin.show(
      0,
      title,
      body,
      platformChannelSpecifics,
    );
  }
  
  // 予定通知を設定
  Future<void> scheduleNotification(
    int id,
    String title,
    String body,
    DateTime scheduledTime,
  ) async {
    const AndroidNotificationDetails androidPlatformChannelSpecifics =
        AndroidNotificationDetails(
      'pomodoro_scheduled_channel',
      '予定ポモドーロ通知',
      channelDescription: 'ポモドーロタイマーの予定通知チャンネル',
      importance: Importance.max,
      priority: Priority.high,
    );
    
    const IOSNotificationDetails iOSPlatformChannelSpecifics =
        IOSNotificationDetails();
    
    const NotificationDetails platformChannelSpecifics = NotificationDetails(
      android: androidPlatformChannelSpecifics,
      iOS: iOSPlatformChannelSpecifics,
    );
    
    await _flutterLocalNotificationsPlugin.zonedSchedule(
      id,
      title,
      body,
      scheduledTime,
      platformChannelSpecifics,
      androidAllowWhileIdle: true,
      uiLocalNotificationDateInterpretation:
          UILocalNotificationDateInterpretation.absoluteTime,
    );
  }
  
  // 通知をキャンセル
  Future<void> cancelNotification(int id) async {
    await _flutterLocalNotificationsPlugin.cancel(id);
  }
  
  // すべての通知をキャンセル
  Future<void> cancelAllNotifications() async {
    await _flutterLocalNotificationsPlugin.cancelAll();
  }
}


/*



































*/
// utils/platform_utils.dart - プラットフォーム固有の機能を提供するユーティリティ
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:platform/platform.dart';
import '../services/app_platform_service.dart';

class PlatformUtils {
  static final PlatformUtils _instance = PlatformUtils._internal();
  factory PlatformUtils() => _instance;
  
  PlatformUtils._internal();
  
  // 現在のプラットフォームを取得
  final Platform platform = const LocalPlatform();
  
  // Windowsプラットフォームかどうか
  bool get isWindows => platform.isWindows;
  
  // Androidプラットフォームかどうか
  bool get isAndroid => platform.isAndroid;
  
  // iOSプラットフォームかどうか
  bool get isIOS => platform.isIOS;
  
  // モバイルプラットフォームかどうか
  bool get isMobile => isAndroid || isIOS;
  
  // デスクトッププラットフォームかどうか
  bool get isDesktop => isWindows || platform.isLinux || platform.isMacOS;

  // プラットフォーム固有のサービスを取得
  AppPlatformService getPlatformService() {
    if (isWindows) {
      return WindowsPlatformService();
    } else if (isAndroid) {
      return AndroidPlatformService();
    } else if (isIOS) {
      return IOSPlatformService();
    } else {
      return DefaultPlatformService();
    }
  }
}

// services/app_platform_service.dart - プラットフォーム固有のサービス抽象クラス
import 'package:shared_preferences/shared_preferences.dart';

// プラットフォーム固有の機能を提供する抽象クラス
abstract class AppPlatformService {
  // アプリをバックグラウンドで実行できるかどうか
  bool get supportsBackgroundExecution;
  
  // アプリ制限機能をサポートしているかどうか
  bool get supportsAppRestriction;
  
  // 設定を初期化
  Future<void> initializeSettings();
  
  // 通知をサポートしているかどうか
  bool get supportsNotifications;

  // バイブレーションをサポートしているかどうか
  bool get supportsVibration;
  
  // バイブレーションを実行
  Future<void> vibrate();
  
  // スタートアップ時に自動実行するように設定
  Future<bool> setAutoStartEnabled(bool enabled);
  
  // スタートアップ時に自動実行が有効かどうか
  Future<bool> isAutoStartEnabled();
}

// Windowsプラットフォーム向けの実装
class WindowsPlatformService implements AppPlatformService {
  @override
  bool get supportsBackgroundExecution => true;
  
  @override
  bool get supportsAppRestriction => true;
  
  @override
  bool get supportsNotifications => true;
  
  @override
  bool get supportsVibration => false;
  
  @override
  Future<void> initializeSettings() async {
    // Windows固有の設定初期化
    final prefs = await SharedPreferences.getInstance();
    
    // デフォルト設定が存在しない場合は初期値を設定
    if (!prefs.containsKey('workDuration')) {
      await prefs.setInt('workDuration', 25);
    }
    if (!prefs.containsKey('shortBreakDuration')) {
      await prefs.setInt('shortBreakDuration', 5);
    }
    if (!prefs.containsKey('longBreakDuration')) {
      await prefs.setInt('longBreakDuration', 15);
    }
    if (!prefs.containsKey('longBreakInterval')) {
      await prefs.setInt('longBreakInterval', 4);
    }
    if (!prefs.containsKey('enableNotifications')) {
      await prefs.setBool('enableNotifications', true);
    }
    if (!prefs.containsKey('enableSounds')) {
      await prefs.setBool('enableSounds', true);
    }
    if (!prefs.containsKey('themeMode')) {
      await prefs.setString('themeMode', 'system');
    }
  }
  
  @override
  Future<void> vibrate() async {
    // Windowsではバイブレーション非対応
    return;
  }
  
  @override
  Future<bool> setAutoStartEnabled(bool enabled) async {
    // Windowsのレジストリに自動起動設定を書き込む
    // 実際の実装ではWin32 APIを使用してレジストリを操作
    try {
      // Windowsレジストリに設定を書き込むコード
      // 例: HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool('autoStartEnabled', enabled);
      return true;
    } catch (e) {
      print('自動起動の設定に失敗しました: $e');
      return false;
    }
  }
  
  @override
  Future<bool> isAutoStartEnabled() async {
    // 自動起動が有効かどうかを確認
    try {
      final prefs = await SharedPreferences.getInstance();
      return prefs.getBool('autoStartEnabled') ?? false;
    } catch (e) {
      print('自動起動設定の取得に失敗しました: $e');
      return false;
    }
  }
}

// Androidプラットフォーム向けの実装
class AndroidPlatformService implements AppPlatformService {
  @override
  bool get supportsBackgroundExecution => true;
  
  @override
  bool get supportsAppRestriction => false;
  
  @override
  bool get supportsNotifications => true;
  
  @override
  bool get supportsVibration => true;
  
  @override
  Future<void> initializeSettings() async {
    // Android固有の設定初期化
    final prefs = await SharedPreferences.getInstance();
    
    // デフォルト設定が存在しない場合は初期値を設定
    if (!prefs.containsKey('workDuration')) {
      await prefs.setInt('workDuration', 25);
    }
    if (!prefs.containsKey('shortBreakDuration')) {
      await prefs.setInt('shortBreakDuration', 5);
    }
    if (!prefs.containsKey('longBreakDuration')) {
      await prefs.setInt('longBreakDuration', 15);
    }
    if (!prefs.containsKey('longBreakInterval')) {
      await prefs.setInt('longBreakInterval', 4);
    }
    if (!prefs.containsKey('enableNotifications')) {
      await prefs.setBool('enableNotifications', true);
    }
    if (!prefs.containsKey('enableSounds')) {
      await prefs.setBool('enableSounds', true);
    }
    if (!prefs.containsKey('enableVibration')) {
      await prefs.setBool('enableVibration', true);
    }
    if (!prefs.containsKey('themeMode')) {
      await prefs.setString('themeMode', 'system');
    }
    if (!prefs.containsKey('keepScreenOn')) {
      await prefs.setBool('keepScreenOn', true);
    }
  }
  
  @override
  Future<void> vibrate() async {
    // バイブレーション実行
    // 実際の実装ではVibration pluginを使用
    try {
      // HapticFeedback.vibrate() などを使用
    } catch (e) {
      print('バイブレーション実行エラー: $e');
    }
  }
  
  @override
  Future<bool> setAutoStartEnabled(bool enabled) async {
    // Androidでは直接自動起動を設定できないため、
    // ユーザーに設定方法を案内する必要がある
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('autoStartEnabled', enabled);
    return true;
  }
  
  @override
  Future<bool> isAutoStartEnabled() async {
    // 自動起動設定の状態を確認
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool('autoStartEnabled') ?? false;
  }
}

// iOSプラットフォーム向けの実装
class IOSPlatformService implements AppPlatformService {
  @override
  bool get supportsBackgroundExecution => false;
  
  @override
  bool get supportsAppRestriction => false;
  
  @override
  bool get supportsNotifications => true;
  
  @override
  bool get supportsVibration => true;
  
  @override
  Future<void> initializeSettings() async {
    // iOS固有の設定初期化
    final prefs = await SharedPreferences.getInstance();
    
    // デフォルト設定が存在しない場合は初期値を設定
    if (!prefs.containsKey('workDuration')) {
      await prefs.setInt('workDuration', 25);
    }
    if (!prefs.containsKey('shortBreakDuration')) {
      await prefs.setInt('shortBreakDuration', 5);
    }
    if (!prefs.containsKey('longBreakDuration')) {
      await prefs.setInt('longBreakDuration', 15);
    }
    if (!prefs.containsKey('longBreakInterval')) {
      await prefs.setInt('longBreakInterval', 4);
    }
    if (!prefs.containsKey('enableNotifications')) {
      await prefs.setBool('enableNotifications', true);
    }
    if (!prefs.containsKey('enableSounds')) {
      await prefs.setBool('enableSounds', true);
    }
    if (!prefs.containsKey('enableVibration')) {
      await prefs.setBool('enableVibration', true);
    }
    if (!prefs.containsKey('themeMode')) {
      await prefs.setString('themeMode', 'system');
    }
  }
  
  @override
  Future<void> vibrate() async {
    // バイブレーション実行
    try {
      // HapticFeedback.vibrate() などを使用
    } catch (e) {
      print('バイブレーション実行エラー: $e');
    }
  }
  
  @override
  Future<bool> setAutoStartEnabled(bool enabled) async {
    // iOSでは自動起動をサポートしていないため、何もしない
    return false;
  }
  
  @override
  Future<bool> isAutoStartEnabled() async {
    // iOSでは自動起動をサポートしていないため、常にfalse
    return false;
  }
}

// デフォルトのプラットフォームサービス（未対応プラットフォーム用）
class DefaultPlatformService implements AppPlatformService {
  @override
  bool get supportsBackgroundExecution => false;
  
  @override
  bool get supportsAppRestriction => false;
  
  @override
  bool get supportsNotifications => false;
  
  @override
  bool get supportsVibration => false;
  
  @override
  Future<void> initializeSettings() async {
    // 基本設定のみ初期化
    final prefs = await SharedPreferences.getInstance();
    
    if (!prefs.containsKey('workDuration')) {
      await prefs.setInt('workDuration', 25);
    }
    if (!prefs.containsKey('shortBreakDuration')) {
      await prefs.setInt('shortBreakDuration', 5);
    }
    if (!prefs.containsKey('longBreakDuration')) {
      await prefs.setInt('longBreakDuration', 15);
    }
    if (!prefs.containsKey('longBreakInterval')) {
      await prefs.setInt('longBreakInterval', 4);
    }
    if (!prefs.containsKey('themeMode')) {
      await prefs.setString('themeMode', 'system');
    }
  }
  
  @override
  Future<void> vibrate() async {
    // 何もしない
    return;
  }
  
  @override
  Future<bool> setAutoStartEnabled(bool enabled) async {
    // サポートされていないため、常にfalse
    return false;
  }
  
  @override
  Future<bool> isAutoStartEnabled() async {
    // サポートされていないため、常にfalse
    return false;
  }
}

// services/background_service.dart - バックグラウンド実行サービス
import 'dart:isolate';
import 'dart:ui';
import 'package:shared_preferences/shared_preferences.dart';
import '../utils/platform_utils.dart';

// バックグラウンド実行を管理するサービス
class BackgroundService {
  static final BackgroundService _instance = BackgroundService._internal();
  factory BackgroundService() => _instance;
  
  BackgroundService._internal();
  
  static const String _isolateName = 'pomodoro_isolate';
  final ReceivePort _receivePort = ReceivePort();
  
  bool _isRunning = false;
  Isolate? _isolate;
  
  // バックグラウンドサービスの状態
  bool get isRunning => _isRunning;
  
  // バックグラウンドサービスの初期化
  Future<void> initialize() async {
    // プラットフォームがバックグラウンド実行をサポートしているか確認
    final platformUtils = PlatformUtils();
    final platformService = platformUtils.getPlatformService();
    
    if (!platformService.supportsBackgroundExecution) {
      print('このプラットフォームはバックグラウンド実行をサポートしていません');
      return;
    }

    // Isolateの登録
    final success = IsolateNameServer.registerPortWithName(
      _receivePort.sendPort,
      _isolateName,
    );
    
    if (!success) {
      // すでに登録されている場合は削除して再登録
      IsolateNameServer.removePortNameMapping(_isolateName);
      IsolateNameServer.registerPortWithName(
        _receivePort.sendPort,
        _isolateName,
      );
    }
    
    // メッセージリスナーを設定
    _receivePort.listen(_handleMessage);
    
    // 設定から自動起動が有効かどうかを確認
    final prefs = await SharedPreferences.getInstance();
    final autoStart = prefs.getBool('autoStartBackgroundService') ?? false;
    
    if (autoStart) {
      await startService();
    }
  }
  
  // バックグラウンドサービスを開始
  Future<bool> startService() async {
    if (_isRunning) {
      return true;
    }
    
    try {
      // Isolateでバックグラウンド処理を開始
      _isolate = await Isolate.spawn(
        _backgroundIsolateEntryPoint,
        IsolateNameServer.lookupPortByName(_isolateName)!,
      );
      
      _isRunning = true;
      return true;
    } catch (e) {
      print('バックグラウンドサービスの開始に失敗しました: $e');
      _isRunning = false;
      return false;
    }
  }
  
  // バックグラウンドサービスを停止
  Future<bool> stopService() async {
    if (!_isRunning) {
      return true;
    }
    
    try {
      // Isolateを終了
      _isolate?.kill(priority: Isolate.immediate);
      _isolate = null;
      
      _isRunning = false;
      return true;
    } catch (e) {
      print('バックグラウンドサービスの停止に失敗しました: $e');
      return false;
    }
  }
  
  // バックグラウンドIsolateからのメッセージを処理
  void _handleMessage(dynamic message) {
    if (message is Map<String, dynamic>) {
      final type = message['type'] as String?;
      
      switch (type) {
        case 'log':
          print('バックグラウンド: ${message['message']}');
          break;
        case 'timer_completed':
          // タイマー完了のメッセージを処理
          break;
        case 'error':
          print('バックグラウンドエラー: ${message['message']}');
          break;
      }
    }
  }
}

// バックグラウンドIsolateのエントリーポイント
void _backgroundIsolateEntryPoint(SendPort sendPort) {
  // バックグラウンド処理のロジック
  final receivePort = ReceivePort();
  sendPort.send({
    'type': 'log',
    'message': 'バックグラウンドサービスが開始されました',
  });
  
  // メッセージ受信の設定
  receivePort.listen((message) {
    if (message is Map<String, dynamic>) {
      final type = message['type'] as String?;
      
      switch (type) {
        case 'stop':
          Isolate.exit();
          break;
      }
    }
  });
  
  // バックグラウンド処理を実行
  _runBackgroundTasks(sendPort);
}

// バックグラウンドタスクの実行
void _runBackgroundTasks(SendPort sendPort) async {
  try {
    // ここでバックグラウンドでの定期処理を実装
    // 例: 定期的なデータ同期、通知のスケジュール管理など
  } catch (e) {
    sendPort.send({
      'type': 'error',
      'message': 'バックグラウンドタスクでエラーが発生しました: $e',
    });
  }
}

// メインアプリケーションの初期化コードを更新 (main.dart)
// void main() async {
//   WidgetsFlutterBinding.ensureInitialized();
//   await DatabaseHelper.instance.database;
//   await NotificationService().init();
//   
//   // プラットフォーム固有の設定初期化
//   final platformService = PlatformUtils().getPlatformService();
//   await platformService.initializeSettings();
//   
//   // バックグラウンドサービスの初期化
//   if (platformService.supportsBackgroundExecution) {
//     await BackgroundService().initialize();
//   }
//   
//   // アプリ設定の読み込み
//   final prefs = await SharedPreferences.getInstance();
//   
//   runApp(
//     MultiProvider(
//       providers: [
//         ChangeNotifierProvider(create: (_) => TaskProvider()),
//         ChangeNotifierProvider(create: (_) => PomodoroProvider(prefs)),
//         ChangeNotifierProvider(create: (_) => AppRestrictionProvider()),
//         ChangeNotifierProvider(create: (_) => TickTickProvider()),
//         ChangeNotifierProvider(create: (_) => ThemeProvider(prefs)),
//       ],
//       child: const MyApp(),
//     ),
//   );
// }

// providers/theme_provider.dart - テーマ設定プロバイダー
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ThemeProvider with ChangeNotifier {
  final SharedPreferences prefs;
  
  // テーマモード（system, light, dark）
  ThemeMode _themeMode = ThemeMode.system;
  
  ThemeProvider(this.prefs) {
    // 保存されたテーマ設定を読み込む
    final themeModeString = prefs.getString('themeMode') ?? 'system';
    _themeMode = _stringToThemeMode(themeModeString);
  }
  
  // 現在のテーマモード
  ThemeMode get themeMode => _themeMode;
  
  // テーマモードを設定
  Future<void> setThemeMode(ThemeMode mode) async {
    _themeMode = mode;
    await prefs.setString('themeMode', _themeModeToString(mode));
    notifyListeners();
  }
  
  // テーマモード名をThemeModeに変換
  ThemeMode _stringToThemeMode(String themeModeString) {
    switch (themeModeString) {
      case 'light':
        return ThemeMode.light;
      case 'dark':
        return ThemeMode.dark;
      case 'system':
      default:
        return ThemeMode.system;
    }
  }
  
  // ThemeModeを文字列に変換
  String _themeModeToString(ThemeMode themeMode) {
    switch (themeMode) {
      case ThemeMode.light:
        return 'light';
      case ThemeMode.dark:
        return 'dark';
      case ThemeMode.system:
      default:
        return 'system';
    }
  }
  
  // ライトテーマ
  ThemeData get lightTheme {
    return ThemeData(
      primarySwatch: Colors.red,
      brightness: Brightness.light,
      visualDensity: VisualDensity.adaptivePlatformDensity,
      fontFamily: 'NotoSansJP',
      appBarTheme: const AppBarTheme(
        elevation: 0,
        centerTitle: true,
      ),
      cardTheme: CardTheme(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 12,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 12,
          ),
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 12,
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 12,
        ),
      ),
    );
  }
  
  // ダークテーマ
  ThemeData get darkTheme {
    return ThemeData(
      primarySwatch: Colors.red,
      brightness: Brightness.dark,
      visualDensity: VisualDensity.adaptivePlatformDensity,
      fontFamily: 'NotoSansJP',
      appBarTheme: const AppBarTheme(
        elevation: 0,
        centerTitle: true,
      ),
      cardTheme: CardTheme(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 12,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 12,
          ),
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 12,
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 12,
        ),
      ),
    );
  }
}

// main.dartを更新して、ThemeProviderを使用するようにする
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'screens/home_screen.dart';
import 'screens/tasks_screen.dart';
import 'screens/statistics_screen.dart';
import 'screens/settings_screen.dart';
import 'providers/task_provider.dart';
import 'providers/pomodoro_provider.dart';
import 'providers/app_restriction_provider.dart';
import 'providers/ticktick_provider.dart';
import 'providers/theme_provider.dart';
import 'services/database_helper.dart';
import 'services/notification_service.dart';
import 'services/background_service.dart';
import 'utils/platform_utils.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await DatabaseHelper.instance.database;
  await NotificationService().init();
  
  // プラットフォーム固有の設定初期化
  final platformService = PlatformUtils().getPlatformService();
  await platformService.initializeSettings();
  
  // バックグラウンドサービスの初期化
  if (platformService.supportsBackgroundExecution) {
    await BackgroundService().initialize();
  }
  
  // アプリ設定の読み込み
  final prefs = await SharedPreferences.getInstance();
  
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => TaskProvider()),
        ChangeNotifierProvider(create: (_) => PomodoroProvider(prefs)),
        ChangeNotifierProvider(create: (_) => AppRestrictionProvider()),
        ChangeNotifierProvider(create: (_) => TickTickProvider()),
        ChangeNotifierProvider(create: (_) => ThemeProvider(prefs)),
      ],
      child: const MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final themeProvider = Provider.of<ThemeProvider>(context);
    
    return MaterialApp(
      title: 'ポモドーロ学習管理',
      theme: themeProvider.lightTheme,
      darkTheme: themeProvider.darkTheme,
      themeMode: themeProvider.themeMode,
      home: const MainScreen(),
      debugShowCheckedModeBanner: false,
    );
  }
}

class MainScreen extends StatefulWidget {
  const MainScreen({Key? key}) : super(key: key);

  @override
  _MainScreenState createState() => _MainScreenState();
}

class _MainScreenState extends State<MainScreen> {
  int _selectedIndex = 0;
  
  final List<Widget> _screens = [
    const HomeScreen(),
    const TasksScreen(),
    const StatisticsScreen(),
    const SettingsScreen(),
  ];

  @override
  Widget build(BuildContext context) {
    // プラットフォームに応じてUIを調整
    final isDesktop = PlatformUtils().isDesktop;
    
    return Scaffold(
      body: Row(
        children: [
          // デスクトップの場合は左側にナビゲーションレールを表示
          if (isDesktop)
            NavigationRail(
              selectedIndex: _selectedIndex,
              onDestinationSelected: (index) {
                setState(() {
                  _selectedIndex = index;
                });
              },
              labelType: NavigationRailLabelType.selected,
              destinations: const [
                NavigationRailDestination(
                  icon: Icon(Icons.home_outlined),
                  selectedIcon: Icon(Icons.home),
                  label: Text('ホーム'),
                ),
                NavigationRailDestination(
                  icon: Icon(Icons.task_outlined),
                  selectedIcon: Icon(Icons.task),
                  label: Text('タスク'),
                ),
                NavigationRailDestination(
                  icon: Icon(Icons.bar_chart_outlined),
                  selectedIcon: Icon(Icons.bar_chart),
                  label: Text('統計'),
                ),
                NavigationRailDestination(
                  icon: Icon(Icons.settings_outlined),
                  selectedIcon: Icon(Icons.settings),
                  label: Text('設定'),
                ),
              ],
            ),
          
          // メインコンテンツ
          Expanded(
            child: _screens[_selectedIndex],
          ),
        ],
      ),
      // モバイルの場合は下部にナビゲーションバーを表示
      bottomNavigationBar: isDesktop ? null : BottomNavigationBar(
        type: BottomNavigationBar.Fixed,
        currentIndex: _selectedIndex,
        onTap: (index) {
          setState(() {
            _selectedIndex = index;
          });
        },
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.home_outlined),
            activeIcon: Icon(Icons.home),
            label: 'ホーム',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.task_outlined),
            activeIcon: Icon(Icons.task),
            label: 'タスク',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.bar_chart_outlined),
            activeIcon: Icon(Icons.bar_chart),
            label: '統計',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.settings_outlined),
            activeIcon: Icon(Icons.settings),
            label: '設定',
          ),
        ],
      ),
    );
  }
}


/*


















































*/
# ポモドーロ学習管理アプリ - UIレイアウト設計

## 1. ホーム画面レイアウト

```
+-----------------------------------------------+
|                                               |
|  +-------------------------------------------+  |
|  |                  AppBar                   |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |                                           |  |
|  |     ポモドーロタイマー (CircularTimer)    |  |
|  |                                           |  |
|  |     +-------------------------------+     |  |
|  |     |             25:00             |     |  |
|  |     +-------------------------------+     |  |
|  |                                           |  |
|  |     [開始] [一時停止] [キャンセル]        |  |
|  |                                           |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |            現在のタスク情報              |  |
|  |  タスク名: 数学の宿題                    |  |
|  |  進捗: 2/5 ポモドーロ                    |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |             タスク選択リスト              |  |
|  |  [数学] [英語] [プログラミング]           |  |
|  |  +-----------------------------------+    |  |
|  |  | タスク1                           |    |  |
|  |  +-----------------------------------+    |  |
|  |  | タスク2                           |    |  |
|  |  +-----------------------------------+    |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |              今日の進捗                   |  |
|  |  合計: 5ポモドーロ / 120分                |  |
|  |  [================] 62%                   |  |
|  +-------------------------------------------+  |
|                                               |
+-----------------------------------------------+
```

## 2. タスク管理画面レイアウト

```
+-----------------------------------------------+
|                                               |
|  +-------------------------------------------+  |
|  |                  AppBar                   |  |
|  |                 タスク管理             [🔍]|  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |               フィルターチップ            |  |
|  |  [すべて] [進行中] [完了]                 |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |                検索バー                   |  |
|  |  [🔍                                 ]   |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |             タスクリスト                  |  |
|  |  +-----------------------------------+    |  |
|  |  | タスク名: 数学の宿題              |    |  |
|  |  | カテゴリ: 数学                    |    |  |
|  |  | 進捗: 2/5 [========>     ]       |    |  |
|  |  +-----------------------------------+    |  |
|  |                                           |  |
|  |  +-----------------------------------+    |  |
|  |  | タスク名: 英語のリーディング      |    |  |
|  |  | カテゴリ: 英語                    |    |  |
|  |  | 進捗: 3/4 [============>  ]      |    |  |
|  |  +-----------------------------------+    |  |
|  |                                           |  |
|  |  +-----------------------------------+    |  |
|  |  | タスク名: アプリ開発              |    |  |
|  |  | カテゴリ: プログラミング          |    |  |
|  |  | 進捗: 6/10 [======>        ]     |    |  |
|  |  +-----------------------------------+    |  |
|  +-------------------------------------------+  |
|                                               |
|                      [+]                      |
+-----------------------------------------------+
```

## 3. 統計画面レイアウト

```
+-----------------------------------------------+
|                                               |
|  +-------------------------------------------+  |
|  |                  AppBar                   |  |
|  |                   統計                    |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |                  タブバー                 |  |
|  |  [日別] [週別] [タスク別] [カレンダー]    |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |               サマリーカード              |  |
|  |                                           |  |
|  |  合計: 28ポモドーロ   平均: 4/日          |  |
|  |  合計時間: 12時間30分                     |  |
|  |                                           |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |                 グラフ                    |  |
|  |                                           |  |
|  |  |                                        |  |
|  |  |    |||                                 |  |
|  |  |    |||    |||                          |  |
|  |  |    |||    |||    |||                   |  |
|  |  |    |||    |||    |||    |||            |  |
|  |  +----------------------------------------|  |
|  |      月  火  水  木  金  土  日           |  |
|  |                                           |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |              詳細データ                   |  |
|  |  +-----------------------------------+    |  |
|  |  | 日付 | ポモドーロ数 | 学習時間   |    |  |
|  |  |------|------------|------------|    |  |
|  |  | 6/1  | 5          | 2時間5分    |    |  |
|  |  | 6/2  | 4          | 1時間40分   |    |  |
|  |  | 6/3  | 7          | 2時間55分   |    |  |
|  |  +-----------------------------------+    |  |
|  +-------------------------------------------+  |
|                                               |
+-----------------------------------------------+
```

## 4. 設定画面レイアウト

```
+-----------------------------------------------+
|                                               |
|  +-------------------------------------------+  |
|  |                  AppBar                   |  |
|  |                   設定                    |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |              タイマー設定                 |  |
|  |  作業時間: 25分 [- +]                     |  |
|  |  短い休憩: 5分 [- +]                      |  |
|  |  長い休憩: 15分 [- +]                     |  |
|  |  長い休憩までのポモドーロ数: 4 [- +]      |  |
|  |                                           |  |
|  |  [タイマー設定を保存]                     |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |              通知と音設定                 |  |
|  |  通知: [ON/OFF]                           |  |
|  |  効果音: [ON/OFF]                         |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |                 外観                      |  |
|  |  テーマ: [システム設定に合わせる ▼]       |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |                 連携                      |  |
|  |  TickTick連携 >                           |  |
|  |  アプリ制限設定 >                         |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |             アプリについて                |  |
|  |  バージョン: 1.0.0                        |  |
|  |  プライバシーポリシー >                   |  |
|  |  利用規約 >                               |  |
|  +-------------------------------------------+  |
|                                               |
+-----------------------------------------------+
```

## 5. TickTick連携画面レイアウト

```
+-----------------------------------------------+
|                                               |
|  +-------------------------------------------+  |
|  |                  AppBar                   |  |
|  |              TickTick連携                 |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |             連携状態カード                |  |
|  |  状態: 連携中 / 未連携                    |  |
|  |  最終同期: 2023/6/10 15:30                |  |
|  +-------------------------------------------+  |
|                                               |
|  // 未連携の場合                              |
|  +-------------------------------------------+  |
|  |            TickTickと連携する             |  |
|  |  [TickTickと連携する]                     |  |
|  |                                           |  |
|  |  認証コードを入力:                        |  |
|  |  [                                  ]     |  |
|  |                                           |  |
|  |  [認証コードを送信]                       |  |
|  +-------------------------------------------+  |
|                                               |
|  // 連携済みの場合                            |
|  +-------------------------------------------+  |
|  |        TickTickからタスクをインポート      |  |
|  |  [タスクをインポート]                     |  |
|  |  5件のタスクをインポートしました          |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |               同期設定                    |  |
|  |  ポモドーロ完了時に自動同期: [ON/OFF]     |  |
|  |  タスク完了時に自動同期: [ON/OFF]         |  |
|  |                                           |  |
|  |  [連携を解除]                             |  |
|  +-------------------------------------------+  |
|                                               |
+-----------------------------------------------+
```

## 6. アプリ制限設定画面レイアウト (Windows版のみ)

```
+-----------------------------------------------+
|                                               |
|  +-------------------------------------------+  |
|  |                  AppBar                   |  |
|  |              アプリ制限設定               |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |  アプリ制限を有効にする: [ON/OFF]         |  |
|  |  ポモドーロ目標達成まで指定アプリの使用を  |  |
|  |  制限します                               |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |            制限対象アプリリスト           |  |
|  |  +-----------------------------------+    |  |
|  |  | ゲームアプリ                [ON] |    |  |
|  |  | 必要ポモドーロ: 5回            |    |  |
|  |  +-----------------------------------+    |  |
|  |                                           |  |
|  |  +-----------------------------------+    |  |
|  |  | SNSアプリ                  [ON] |    |  |
|  |  | 必要ポモドーロ: 3回            |    |  |
|  |  +-----------------------------------+    |  |
|  |                                           |  |
|  |  +-----------------------------------+    |  |
|  |  | 動画アプリ                 [OFF]|    |  |
|  |  | 必要ポモドーロ: 8回            |    |  |
|  |  +-----------------------------------+    |  |
|  +-------------------------------------------+  |
|                                               |
|                      [+]                      |
+-----------------------------------------------+
```

## 7. ポモドーロタイマー実行画面

```
+-----------------------------------------------+
|                                               |
|  +-------------------------------------------+  |
|  |                                           |  |
|  |                作業時間                   |  |
|  |                                           |  |
|  |                  ┌───┐                    |  |
|  |                  │     │                  |  |
|  |               ┌──┘     └──┐               |  |
|  |              ┌┘           └┐              |  |
|  |              │             │              |  |
|  |              │    23:45    │              |  |
|  |              │             │              |  |
|  |              └┐           ┌┘              |  |
|  |               └──┐     ┌──┘               |  |
|  |                  │     │                  |  |
|  |                  └───┘                    |  |
|  |                                           |  |
|  |            [一時停止] [中止]              |  |
|  |                                           |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |               現在のタスク                |  |
|  |  タスク名: 数学の宿題                     |  |
|  |  進捗: 2/5 ポモドーロ                     |  |
|  +-------------------------------------------+  |
|                                               |
+-----------------------------------------------+
```

## 8. 休憩タイマー画面

```
+-----------------------------------------------+
|                                               |
|  +-------------------------------------------+  |
|  |                                           |  |
|  |                 休憩時間                  |  |
|  |                                           |  |
|  |                  ┌───┐                    |  |
|  |                  │     │                  |  |
|  |               ┌──┘     └──┐               |  |
|  |              ┌┘           └┐              |  |
|  |              │             │              |  |
|  |              │    04:59    │              |  |
|  |              │             │              |  |
|  |              └┐           ┌┘              |  |
|  |               └──┐     ┌──┘               |  |
|  |                  │     │                  |  |
|  |                  └───┘                    |  |
|  |                                           |  |
|  |                 [スキップ]                |  |
|  |                                           |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |                次のタスク                 |  |
|  |  英語のリーディング                       |  |
|  |  残り: 3/4 ポモドーロ                     |  |
|  +-------------------------------------------+  |
|                                               |
+-----------------------------------------------+
```

## 9. ヒートマップカレンダー

```
+-----------------------------------------------+
|                                               |
|  +-------------------------------------------+  |
|  |           ポモドーロ達成カレンダー        |  |
|  |                                           |  |
|  |  少 □□□□□ 多                             |  |
|  |                                           |  |
|  |      月 火 水 木 金 土 日                 |  |
|  |  1月 □□■■□□■                             |  |
|  |  2月 ■■■□□■■                             |  |
|  |  3月 □■■■□□□                             |  |
|  |  4月 ■■□□■■■                             |  |
|  |  5月 □□■■■□■                             |  |
|  |  6月 ■□■□■□□                             |  |
|  |                                           |  |
|  +-------------------------------------------+  |
|                                               |
|  +-------------------------------------------+  |
|  |                達成記録                   |  |
|  |                                           |  |
|  |   🔥 現在の連続記録: 5日                  |  |
|  |   🏆 最長連続記録: 12日                   |  |
|  |   📅 合計学習日数: 63日                   |  |
|  |                                           |  |
|  |  [================] 100%                  |  |
|  |  今日も学習を完了しました！明日も続けましょう。|  |
|  |                                           |  |
|  +-------------------------------------------+  |
|                                               |
+-----------------------------------------------+
```

## カラーパレット

- **プライマリーカラー**: #F44336 (赤)
- **アクセントカラー**: #2196F3 (青)
- **成功色**: #4CAF50 (緑)
- **警告色**: #FFC107 (黄)
- **エラー色**: #FF5722 (オレンジ)
- **背景色 (ライトモード)**: #FFFFFF (白)
- **テキスト (ライトモード)**: #212121 (ほぼ黒)
- **背景色 (ダークモード)**: #121212 (暗いグレー)
- **テキスト (ダークモード)**: #FFFFFF (白)

## フォント

- 日本語: Noto Sans JP
- 数字/英語: Roboto

## アイコン設計

- **アプリアイコン**: 赤い背景に白いトマトの形をしたタイマーアイコン
- **アクション**: Material Designのアイコンセットを使用
  - 開始: play_arrow
  - 一時停止: pause
  - 停止: stop
  - 追加: add
  - 編集: edit
  - 削除: delete
  - 設定: settings
  - 統計: bar_chart
  - タスク: task
  - ホーム: home
  - 検索: search
  - フィルター: filter_list
